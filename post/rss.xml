<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Nicolas Guilloux</title><link>https://nicolasguilloux.eu/post/</link><description>Recent content in Posts on Nicolas Guilloux</description><generator>Hugo -- gohugo.io</generator><language>fr-fr</language><lastBuildDate>Wed, 11 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://nicolasguilloux.eu/post/rss.xml" rel="self" type="application/rss+xml"/><item><title>Reverse Proxy sur NixOS</title><link>https://nicolasguilloux.eu/articles/reverse-proxy-nixos/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/reverse-proxy-nixos/</guid><description>&lt;img src="https://nicolasguilloux.eu/cover.png" alt="Featured image of post Reverse Proxy sur NixOS" />&lt;div class="paragraph">
&lt;p>J’ai jonglé entre 3 proxies récemment afin de pouvoir facilement rediriger des requêtes vers les services appropriés, que ce soit en utilisant Docker ou en utilisant des services exposant des ports.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_les_softwares">Les softwares&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>J’ai expérimenté les proxies suivants dans l’ordre chronologique. Je vais passer en revue pourquoi je les ai utilisés, et pourquoi je les ai aussi abandonnés.&lt;br/>
Il n’y en a pas nécessairement de meilleurs que d’autres, c’est juste que chacun trouve chaussure à son pied !&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>J’avais aussi utilisé une configuration qui permettait de facilement jongler entre les différents services en adaptant le module sans pour autant rajouter de configuration. C’est d’ailleurs l’un des gros avantages de NixOS : pouvoir dissocier la configuration de l’implémentation. Vous pouvez voir le code &lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/tree/master/modules/reverse-proxies" target="_blank" rel="noopener">ici&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour des raisons de facilité, on va utiliser l’exemple d’un site web qui serait à l’adresse &lt;code>blog.nicolasguilloux.eu&lt;/code> et qui serait disponible en local sur le port 8080. Bien entendu, on souhaite que le site soit en &lt;code>https&lt;/code>.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_nginx">Nginx&lt;/h3>
&lt;div class="paragraph">
&lt;p>C’est le premier proxy que j’ai utilisé, car c’est le serveur web que j’utilisais et qui permettait de facilement mettre en place cette fonctionnalité.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>La première chose à faire est de configurer le Acme challenge ainsi que 4 optimisations recommandées pour Nginx. Le premier servira bien entendu à générer automatiquement le certificat HTTPS pour notre site.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix"># ACME Challenge
security.acme.acceptTerms = true;
security.acme.defaults.email = &amp;#34;nicolas.guilloux@proton.me&amp;#34;;
# Use recommended settings
services.nginx.recommendedGzipSettings = lib.mkDefault true;
services.nginx.recommendedOptimisation = lib.mkDefault true;
services.nginx.recommendedProxySettings = lib.mkDefault true;
services.nginx.recommendedTlsSettings = lib.mkDefault true;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ensuite, il nous faut dire à Nginx de rediriger le traffic entrant de &lt;code>blog.nicolasguilloux.eu&lt;/code> vers le port 8080. Pour ce faire, nous allons déclarer une virtual host, lui donner quelques configurations relatives au SSL et au proxy, mais surtout lui dire de rediriger tout le traffic vers la bonne adresse. La configuration parle d’elle-même :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix">services.nginx.virtualHosts.&amp;#34;blog.nicolasguilloux.eu&amp;#34; = {
forceSSL = true;
enableACME = true;
extraConfig = &amp;#34;proxy_buffering off&amp;#34;;
locations.&amp;#34;/&amp;#34; = {
proxyPass = &amp;#34;http://127.0.0.1:8080&amp;#34;;
proxyWebsockets = true;
extraConfig =
# required when the target is also TLS server with multiple hosts
&amp;#34;proxy_ssl_server_name on;&amp;#34; +
# required when the server wants to use HTTP Authentication
&amp;#34;proxy_pass_header Authorization;&amp;#34;;
};
};&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Nginx était bien mais nécessitait que le service en question expose un port pour être accessible. Comme je travaille beaucoup avec des images Docker, l’utiliser était devenu de plus en plus fastidieux car je devais réfléchir à quel port j’exposais.
Si par exemple j’avais deux sites exposés sur le port 80, je devais choisir de l’exposer l’un sur le port 8080 et l’autre sur le port 8081.&lt;br/>
Bref, rapidement j’ai trouvé que l’attribution arbitraire d’un port pour éviter les conflits n’était pas pérenne dans le temps.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_caddy_proxy">Caddy Proxy&lt;/h3>
&lt;div class="paragraph">
&lt;p>Celui-ci est légèrement différent. C’est une &lt;a href="https://github.com/lucaslorentz/caddy-docker-proxy">image docker&lt;/a> qui a pour principe de se servir des labels associés à un container Docker pour le router.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Regardons comment &amp;#34;installer&amp;#34; le service the nix way :&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>On va devoir déclarer une container qui utilisera le port 80 et 443 pour respectivement le http et https.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On doit donner un petit nom au network Docker. Tout container appartenant à ce network sera analysé par caddy-proxy pour trouver éventuellement des labels le concernant.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On l’ajoute bien entendu à ce dit network.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On lui donne accès à notre socket Docker, pour qu’il puisse analyser les différents containers.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On lui donne un espace pour stocker ses données.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une dernière configuration doit être ajoutée pour créer le network Docker avant de lancer le container pour éviter une erreur.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Voici donc la configuration correspondante :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix">let
dockerNetwork = &amp;#34;caddy-proxy&amp;#34;;
in
{
virtualisation.oci-containers.containers.caddy-proxy = {
autoStart = true;
image = &amp;#34;lucaslorentz/caddy-docker-proxy:ci-alpine&amp;#34;;
ports = [ &amp;#34;80:80&amp;#34; &amp;#34;443:443&amp;#34; ];
environment = { CADDY_INGRESS_NETWORKS = &amp;#34;${dockerNetwork} };
extraOptions = [ &amp;#34;--network=${dockerNetwork} ];
volumes = [
&amp;#34;/var/run/docker.sock:/var/run/docker.sock&amp;#34;
&amp;#34;/var/lib/caddy-proxy:/data&amp;#34;
];
};
systemd.services.docker-caddy-proxy.preStart = lib.mkAfter &amp;#39;&amp;#39;
${pkgs.docker}/bin/docker network create -d bridge ${dockerNetwork} || true
&amp;#39;&amp;#39;;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Et voilà, ça fonctionne. On pourra noter une amélioration à apporter : le support de Podman. Pour l’instant, c’est hardcodé pour Docker à cause de preStart ainsi que du socket.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Si on regarde maintenant pour instancier un service qui passerait par ce proxy, on se retrouverait avec une configuration de ce genre :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix">let
dockerNetwork = &amp;#34;caddy-proxy&amp;#34;;
in
{
virtualisation.oci-containers.containers.whoami = {
autoStart = true;
image = &amp;#34;jwilder/whoami&amp;#34;;
extraOptions = [
&amp;#34;--network=${dockerNetwork}&amp;#34;
&amp;#34;--label=caddy=whoami.example.com&amp;#34;
&amp;#34;--label=caddy.reverse_proxy={{upstreams 8000}}&amp;#34;
];
};
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>J’ai abandonné cette implémentation particulière d’un proxy car étant très pratique pour du développement local avec Docker, elle ne permet pas de facilement placer un service natif derrière celui-ci. De plus, je n’ai pas exploré la possibilité du SSL car je n’envisageais pas cette solution sur mon serveur.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_traefik">Traefik&lt;/h3>
&lt;div class="paragraph">
&lt;p>Ce qu’il me fallait, c’est le meilleur des deux mondes : placer des services natifs et des services dockerisés derrière un proxy. Si en plus je pouvais avoir une interface graphique pour debugger, ça serait parfait.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Traefik m’a alors été conseillé par un ami, et rempli totalement son rôle. On peut lui dire manuellement de forward tel host sur tel adresse et port, tout comme on peut bénéficier d’une configuration avec des labels via le Docker provider.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Voyons quelques prérequis qui expliquent la configuration :&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Traefik doit avoir accès à Docker&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On veut son Dashboard pour pouvoir facilement débugger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On doit configurer au moins deux points d’entrées : un pour le http et l’autre pour le https. Le http dans cette exemple redirigera vers le https.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On doit configurer la génération des certificats&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On souhaite par défaut que le dashboard soit accessible via &lt;code>&lt;a href="https://traefik.local" class="bare">https://traefik.local&lt;/a>&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Avec tout ça en tête, on obtient alors la configuration par défaut suivante :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix">{ config, lib, pkgs, ... }:
let
localCertificationDirectory = config.security.localCertification.directory;
in
{
# Enable Traefik
services.traefik.enable = true;
# Let Traefik interact with Docker
services.traefik.group = &amp;#34;docker&amp;#34;;
services.traefik.staticConfigOptions = {
api.dashboard = true;
api.insecure = false;
# Enable logs
log.filePath = &amp;#34;/var/log/traefik/traefik.log&amp;#34;;
accessLog.filePath = &amp;#34;/var/log/traefik/accessLog.log&amp;#34;;
# Enable Docker provider
providers.docker = {
endpoint = &amp;#34;unix:///run/docker.sock&amp;#34;;
watch = true;
exposedByDefault = false;
};
# Configure entrypoints, i.e the ports
entryPoints = {
websecure.address = &amp;#34;:443&amp;#34;;
web = {
address = &amp;#34;:80&amp;#34;;
http.redirections.entryPoint = {
to = &amp;#34;websecure&amp;#34;;
scheme = &amp;#34;https&amp;#34;;
};
};
};
# Configure certification
certificatesResolvers.acme-challenge.acme = {
email = &amp;#34;nicolas.guilloux@proton.me&amp;#34;;
storage = &amp;#34;/var/lib/traefik/acme.json&amp;#34;;
httpChallenge.entryPoint = &amp;#34;web&amp;#34;;
};
};
# Dashboard
services.traefik.dynamicConfigOptions.http.routers.dashboard = {
rule = lib.mkDefault &amp;#34;Host(`traefik.local`)&amp;#34;;
service = &amp;#34;api@internal&amp;#34;;
entryPoints = [ &amp;#34;websecure&amp;#34; ];
tls = lib.mkDefault true;
# Add certification
# tls.certResolver = &amp;#34;acme-challenge&amp;#34;;
};
# Add Dashboard to hosts
networking.hosts.&amp;#34;127.0.0.1&amp;#34; =
if config.services.traefik.dynamicConfigOptions.http.routers.dashboard.rule == &amp;#34;Host(`traefik.local`)&amp;#34; then
[ &amp;#34;traefik.local&amp;#34; ]
else
[ ];
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>À partir de là, on a un Traefik qui dispose d’un dashboard et qui surveille Docker, quel que soit le network.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;div class="title">Note&lt;/div>
&lt;/td>
&lt;td class="content">
Si jamais vous voulez manipuler des headers, il faut passer par des middlewares.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Regardons déjà la déclaration d’un container pour qu’il soit cabler sur Traefik. L’attribution des labels est plutôt évidentes.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix">virtualisation.oci-containers.containers.whoami = {
autoStart = true;
image = &amp;#34;jwilder/whoami&amp;#34;;
extraOptions = [
&amp;#34;--label=traefik.enable=true&amp;#34;
&amp;#34;--label=traefik.http.routers.whoami.entrypoints=websecure&amp;#34;
&amp;#34;--label=traefik.http.routers.whoami.rule=Host(`whoami.example.com`)&amp;#34;
&amp;#34;--label=traefik.http.routers.whoami.tls=true&amp;#34;
&amp;#34;--label=traefik.http.services.whoami.loadbalancer.server.port=8000&amp;#34;
# Add certification
# &amp;#34;--label=traefik.http.routers.whoami.tls.certresolver=acme-challenge&amp;#34;
];
};&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour ajouter notre fameux blog, c’est-à-dire un service natif, on peut le faire de la manière suivante :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-nix" data-lang="nix">services.traefik.dynamicConfigOptions.http.services.&amp;#34;blog.nicolasguilloux.eu&amp;#34; = {
loadBalancer.servers = [
{ url = &amp;#34;http://127.0.0.1:8080&amp;#34;; }
];
};&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Traefik est pour moi la solution qui me convient le mieux, car elle réunit le meilleur des deux précédents proxy, tout en proposant davantage. Le dashboard est très pratique pour surveiller le routing, et je pourrais explorer d’autres fonctionnalités à l’avenir comme le routing TCP/UDP.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_aller_plus_loin">Aller plus loin&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Il y a plusieurs fonctionnalités que j’ai ou vais explorer avec Traefik :&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Faire de la certification en local (Prochain article !)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Faire du routing TCP/UDP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Implémenter du monitoring&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Implémenter + de securité (Crowdsec ?)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Le Bridge Signal pour Matrix</title><link>https://nicolasguilloux.eu/articles/mautrix-signal/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/mautrix-signal/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/mautrix-signal/cover.svg" alt="Featured image of post Le Bridge Signal pour Matrix" />&lt;div class="paragraph">
&lt;p>Matrix est un protocole de messagerie instantannée. La suite de ce ticket considère que vous connaissez les bases et notamment le glossaire. Je vous conseille fortement d’aller lire le tutoriel précédent :
&lt;a href="../matrix">Matrix sur NixOS&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_telegram_messenger">Telegram Messenger&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/blob/master/server/matrix/signal.nix" target="_blank" rel="noopener">&lt;span class="image">&lt;img src="https://img.shields.io/badge/Gitlab-Mautrix%20Signal-orange" alt="Gitlab"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le bridge Signal supporte les conversations de groupe et les messages directs. Toutefois, toute conversation chiffrée ne sera pas supportée.&lt;br/>
La petite particularité sur ce bridge est que Signal ne dispose pas d’une API. Ainsi, il va falloir utiliser une image Docker qui va simuler un accès Web à Signal.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Voici la configuration que je préconise :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>{ config, lib, ... }:
let
bridgeFolder = &amp;#34;/var/lib/mautrix-signal&amp;#34;;
toListIfExists = path:
if (lib.pathExists path) then
[ path ]
else
[];
in {
# Signal daemon
virtualisation.oci-containers.containers.signald = {
image = &amp;#34;docker.io/finn/signald&amp;#34;;
volumes = [ &amp;#34;${bridgeFolder}/signald:/signald&amp;#34; ];
extraOptions = [ &amp;#34;--network=host&amp;#34; ];
};
# Signal bridge
virtualisation.oci-containers.containers.mautrix-signal = {
image = &amp;#34;dock.mau.dev/tulir/mautrix-signal&amp;#34;;
extraOptions = [ &amp;#34;--network=host&amp;#34; ];
dependsOn = [ &amp;#34;signald&amp;#34; ];
volumes = [
&amp;#34;${bridgeFolder}/data:/data&amp;#34;
&amp;#34;${bridgeFolder}/signald:/signald&amp;#34;
];
};
# Add configuration to Matrix server
services.matrix-synapse.app_service_config_files = toListIfExists &amp;#34;${bridgeFolder}/data/registration.yaml&amp;#34;;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Si on résume, toutes les données sont stockées dans &lt;code>/var/lib/mautrix-signal&lt;/code>. On ajoute les image Docker qui permet de lancer le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>L’image &lt;code>signald&lt;/code> est le daemon pour pouvoir simuler une interface Web auprès de notre application Signal. C’est nécessaire pour pouvoir récupérer les messages en toute sécurité vu que Signal ne dispose pas d’API.&lt;br/>
C’est aussi pour celà qu’on doit partager le volume où sont stockées toutes les informations (comme les avatars) entre le daemon et le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va dès maintenant configurer ce dernier en éditant &lt;strong>en tant que root&lt;/strong> le fichier &lt;code>/var/lib/mautrix-signal/data/config.yaml&lt;/code>…​ Enfin faite votre &lt;code>nixos-rebuild switch&lt;/code> pour lancer le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va changer différentes clés dans le fichier, je vais lister ce les clés qui ont changé :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>homeserver:
address: http://localhost:8008
domain: server_name
verify_ssl: false
signal:
socket_path: /signald/signald.sock
outgoing_attachment_dir: /signald/attachments
avatar_dir: /signald/avatars
data_dir: /signald/data
bridge:
permissions:
&amp;#34;*&amp;#34;: user
&amp;#34;@pseudo:server_name&amp;#34;: admin&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>homeserver.address&lt;/code> : Votre serveur Matrix, pas besoin de passer par internet, il est disponible en local&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>homeserver.domain&lt;/code> : C’est le &lt;code>server_name&lt;/code>, vous devez maintenance savoir ce que c’est :)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>homeserver.verify_ssl&lt;/code> : Comme on est dans une boucle locale, par besoin de vérifier le SSL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>signal.socket-path&lt;/code> : Socket pour dialoguer avec le daemon&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>signal.outgoing_attachment_dir&lt;/code> : Répertoire du daemon où sont mis les pièces jointes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>signal.avatar_dir&lt;/code> : Répertoire du daemon où sont mis les avatars&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>signal.data_dir&lt;/code> : Répertoire du daemon où sont mis les autres données utiles aux bridges&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bridge.permissions&lt;/code> : Ce sont les permissions. Pour ma part, j’ai mis &lt;code>&amp;#34;*&amp;#34;: user&lt;/code> pour que tous les utilisateurs puissent utiliser le bridge, et enfin &lt;code>&amp;#34;@pseudo:server_name&amp;#34;: admin&lt;/code> pour que votre utilisateur puisse l’administrer&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois ça fait, pensez à redémarrer votre image docker &lt;code>docker restart mautrix-signal&lt;/code> et faites ensuite un petit &lt;code>nixos-rebuild switch&lt;/code>. Normalement, &lt;code>matrix-synapse&lt;/code> se redémarrera car le fichier &lt;code>registration.yaml&lt;/code> existera.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Vous pouvez maintenant constater que vous pouvez parler au bot dans votre client Matrix en ouvrant une conversation avec &lt;code>@signalbot:server_name&lt;/code>.&lt;br/>
Celui-ci devrait accepter votre invitation. Vous pouvez alors lui demander de l’aide comme il le propose.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>A partir d’ici vous avez plusieurs choix, car vous pouvez :&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Créer un compte de zéro en utilisant la commande &lt;code>register +33xxxxxxxxx&lt;/code>. Si vous n’avez pas signal sur votre téléphone, cela permettra de tout recevoir sur Matrix directement.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Lier votre compte déjà existant, relié à votre téléphone, et forward tous les messages à Matrix en tapant &lt;code>link&lt;/code> et en scannant le QR Code.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois connecté, attendez un peu et vous allez recevoir plein d’invitations :) Bien joué, tout devrait fonctionner !&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Le Bridge Telegram pour Matrix</title><link>https://nicolasguilloux.eu/articles/mautrix-telegram/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/mautrix-telegram/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/mautrix-telegram/cover.svg" alt="Featured image of post Le Bridge Telegram pour Matrix" />&lt;div class="paragraph">
&lt;p>Matrix est un protocole de messagerie instantannée. La suite de ce ticket considère que vous connaissez les bases et notamment le glossaire. Je vous conseille fortement d’aller lire le tutoriel précédent :
&lt;a href="../matrix">Matrix sur NixOS&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_telegram_messenger">Telegram Messenger&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/blob/master/server/matrix/telegram.nix" target="_blank" rel="noopener">&lt;span class="image">&lt;img src="https://img.shields.io/badge/Gitlab-Mautrix%20Telegram-orange" alt="Gitlab"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le bridge de Telegram supporte quasiment toutes les fonctionnalités. La configuration est quasiment la même que pour
&lt;a href="../mautrix-facebook">Mautrix Facebook&lt;/a>
hormis un léger changement au niveau de la configuration d’une API.&lt;br/>
Je n’ai volontairement pas suivi la configuration proposé par NixOS car je n’ai jamais réussi à la faire fonctionner, et je souhaite avoir une installation cohérente. Comme NixOS ne propose pas de module pour Mautrix Facebook, Mautrix Telegram et Mautrix Signal, je préfère les configurer de la même manière.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Voici la configuration que je préconise :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>{ config, lib, ... }:
let
bridgeFolder = &amp;#34;/var/lib/mautrix-telegram&amp;#34;;
toListIfExists = path:
if (lib.pathExists path) then
[ path ]
else
[];
in {
# Telegram bridge
virtualisation.oci-containers.containers.mautrix-telegram = {
image = &amp;#34;dock.mau.dev/tulir/mautrix-telegram&amp;#34;;
extraOptions = [ &amp;#34;--network=host&amp;#34; ];
volumes = [ &amp;#34;${bridgeFolder}/data:/data&amp;#34; ];
};
# Add configuration to Matrix server
services.matrix-synapse.app_service_config_files = toListIfExists &amp;#34;${bridgeFolder}/data/registration.yaml&amp;#34;;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Si on résume, toutes les données sont stockées dans &lt;code>/var/lib/mautrix-telegram&lt;/code>. On ajoute l’image docker qui permet de lancer le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va dès maintenant le configurer en éditant &lt;strong>en tant que root&lt;/strong> le fichier &lt;code>/var/lib/mautrix-telegram/data/config.yaml&lt;/code>…​ Enfin faite votre &lt;code>nixos-rebuild switch&lt;/code> pour lancer le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Dans un premier temps, il faut faire une application sur le site de Telegram pour récupérer un ID et un hash qui serviront au bridge pour interagir avec l’API. Pour ce faire, allez sur cette &lt;a href="https://core.telegram.org/api/obtaining_api_id#obtaining" target="_blank" rel="noopener">page d’aide de Telegram&lt;/a> et suivez les instructions pour récupérer le &lt;code>api_id&lt;/code> et le &lt;code>api_hash&lt;/code>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va changer différentes clés dans le fichier, je vais lister ce les clés qui ont changé :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>homeserver:
address: http://localhost:8008
domain: server_name
verify_ssl: false
telegram:
api_id: #ApiId#
api_hash: #ApiHash#
bridge:
permissions:
&amp;#34;*&amp;#34;: user
&amp;#34;@pseudo:server_name&amp;#34;: admin&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>homeserver.address&lt;/code> : Votre serveur Matrix, pas besoin de passer par internet, il est disponible en local&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>homeserver.domain&lt;/code> : C’est le &lt;code>server_name&lt;/code>, vous devez maintenance savoir ce que c’est :)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>homeserver.verify_ssl&lt;/code> : Comme on est dans une boucle locale, par besoin de vérifier le SSL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>telegram.api_id&lt;/code> : ID fourni par Telegram sur le site&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>telegram.api_hash&lt;/code> : Hash fourni par Telegram sur le site&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bridge.permissions&lt;/code> : Ce sont les permissions. Pour ma part, j’ai mis &lt;code>&amp;#34;*&amp;#34;: user&lt;/code> pour que tous les utilisateurs puissent utiliser le bridge, et enfin &lt;code>&amp;#34;@pseudo:server_name&amp;#34;: admin&lt;/code> pour que votre utilisateur puisse l’administrer&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois ça fait, pensez à redémarrer votre image docker &lt;code>docker restart mautrix-telegram&lt;/code> et faites ensuite un petit &lt;code>nixos-rebuild switch&lt;/code>. Normalement, &lt;code>matrix-synapse&lt;/code> se redémarrera car le fichier &lt;code>registration.yaml&lt;/code> existera.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Vous pouvez maintenant constater que vous pouvez parler au bot dans votre client Matrix en ouvrant une conversation avec &lt;code>@telegrambot:server_name&lt;/code>.&lt;br/>
Celui-ci devrait accepter votre invitation. Vous pouvez alors lui demander de l’aide comme il le propose. Pour lier votre compte, faites &lt;code>!tg login&lt;/code> et suivez les instructions.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois connecté, attendez un peu et vous allez recevoir plein d’invitations :) Bien joué, tout devrait fonctionner !&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Le Bridge Facebook pour Matrix</title><link>https://nicolasguilloux.eu/articles/mautrix-facebook/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/mautrix-facebook/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/mautrix-facebook/cover.svg" alt="Featured image of post Le Bridge Facebook pour Matrix" />&lt;div class="paragraph">
&lt;p>Matrix est un protocole de messagerie instantannée. La suite de ce ticket considère que vous connaissez les bases et notamment le glossaire. Je vous conseille fortement d’aller lire le tutoriel précédent :
&lt;a href="../matrix">Matrix sur NixOS&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_facebook_messenger">Facebook Messenger&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/blob/master/server/matrix/facebook.nix" target="_blank" rel="noopener">&lt;span class="image">&lt;img src="https://img.shields.io/badge/Gitlab-Mautrix%20Facebook-orange" alt="Gitlab"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Bon, qu’on se le dise, j’aimerai bien partir de Facebook mais beaucoup de personnes ne veulent pas par simplicité. Même si ça m’embête pour des raisons évidentes, je dois rester dessus car j’ai vraiment des personnes que j’aime beaucoup qui refusent de passer sur d’autres plateformes.&lt;br/>
C’est d’ailleurs un intérêt de ce bridge : je vais désinstaller toutes les applications Facebook, ma seule interaction sera via Matrix.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Dans un premier temps, on va préparer notre base de données afin d’y stocker les données utilent au bridge. Pour le moment, celui-ci ne supporte que PostgreSQL. Ca tombe bien, on a déjà une BDD disponible via le serveur Synapse. Aussi, on va pouvoir facilement créer un user et une base.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>sudo -u postgres psql
CREATE ROLE &amp;#34;mautrixfacebook&amp;#34; WITH LOGIN PASSWORD &amp;#39;VotreMotDePasseUnique&amp;#39;;
CREATE DATABASE &amp;#34;mautrixfacebook&amp;#34; WITH OWNER &amp;#34;mautrixfacebook&amp;#34; TEMPLATE template0 LC_COLLATE = &amp;#34;C&amp;#34; LC_CTYPE = &amp;#34;C&amp;#34;;
\q&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois fait, on va pouvoir préparer notre module qui va démarrer l’image docker du bridge. On va aussi câbler ce bridge à notre instance Matrix.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>{ config, lib, ... }:
let
bridgeFolder = &amp;#34;/var/lib/mautrix-facebook&amp;#34;;
toListIfExists = path:
if (lib.pathExists path) then
[ path ]
else
[];
in {
# Facebook bridge
virtualisation.oci-containers.containers.mautrix-facebook = {
image = &amp;#34;dock.mau.dev/tulir/mautrix-facebook&amp;#34;;
extraOptions = [ &amp;#34;--network=host&amp;#34; ];
volumes = [ &amp;#34;${bridgeFolder}/data:/data&amp;#34; ];
};
# Add configuration to Matrix server
services.matrix-synapse.app_service_config_files = toListIfExists &amp;#34;${bridgeFolder}/data/registration.yaml&amp;#34;;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Si on résume, toutes les données sont stockées dans &lt;code>/var/lib/mautrix-facebook&lt;/code>. On ajoute l’image docker qui permet de lancer le bridge.&lt;br/>
La partie où on relie notre bridge à notre serveur est commentée pour le moment car le fichier en question sera généré par le bridge, et donc n’existe pas avant d’avoir bien parametré le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va dès maintenant le configurer en éditant &lt;strong>en tant que root&lt;/strong> le fichier &lt;code>/var/lib/mautrix-facebook/data/config.yaml&lt;/code>…​ Enfin faite votre &lt;code>nixos-rebuild switch&lt;/code> pour lancer le bridge.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va changer différentes clés dans le fichier, je vais lister ce les clés qui ont changé :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>homeserver:
address: http://localhost:8008
domain: server_name
verify_ssl: false
appservice:
database: postgres://mautrixfacebook:VotreMotDePasseUnique@127.0.0.1/mautrixfacebook
bridge:
permissions:
&amp;#34;*&amp;#34;: user
&amp;#34;@pseudo:server_name&amp;#34;: admin&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>homeserver.address&lt;/code> : Votre serveur Matrix, pas besoin de passer par internet, il est disponible en local&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>homeserver.domain&lt;/code> : C’est le &lt;code>server_name&lt;/code>, vous devez maintenance savoir ce que c’est :)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>homeserver.verify_ssl&lt;/code> : Comme on est dans une boucle locale, par besoin de vérifier le SSL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>appservice.database&lt;/code> : Lien vers *votre base de données. Pensez à changer le mot de passe pour celui que vous avez utilisé au dessus.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bridge.permissions&lt;/code> : Ce sont les permissions. Pour ma part, j’ai mis &lt;code>&amp;#34;*&amp;#34;: user&lt;/code> pour que tous les utilisateurs puissent utiliser le bridge, et enfin &lt;code>&amp;#34;@pseudo:server_name&amp;#34;: admin&lt;/code> pour que votre utilisateur puisse l’administrer&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois ça fait, pensez à redémarrer votre image docker &lt;code>docker restart mautrix-facebook&lt;/code> et faites ensuite un petit &lt;code>nixos-rebuild switch&lt;/code>. Normalement, &lt;code>matrix-synapse&lt;/code> se redémarrera car le fichier &lt;code>registration.yaml&lt;/code> existera.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Vous pouvez maintenant constater que vous pouvez parler au bot dans votre client Matrix en ouvrant une conversation avec &lt;code>@facebookbot:server_name&lt;/code>.&lt;br/>
Celui-ci devrait accepter votre invitation. Vous pouvez alors lui demander de l’aide comme il le propose. Pour lier votre compte, faites &lt;code>login &amp;lt;email&amp;gt;&lt;/code> avec l’email de votre compte Facebook bien entendu ! Suivez ce qu’il vous dit, il va vous demander votre mot de passe et potentiellement votre code de double authentification.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois connecté, attendez un peu et vous allez recevoir plein d’invitations :) Bien joué, tout devrait fonctionner !&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Matrix sur NixOS</title><link>https://nicolasguilloux.eu/articles/matrix/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/matrix/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/matrix/matrix.svg" alt="Featured image of post Matrix sur NixOS" />&lt;div class="paragraph">
&lt;p>Comme beaucoup de personnes, j’ai beaucoup de messageries qui ont su évoluer (ou pas) dans le temps. Et chacunes de ces messageries apportent ses avantages et ses inconvénients, et la plupart des gens ne veulent pas toutes les avoir. Et j’en fais partie !&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Aussi, j’ai toujours reluqué &lt;a href="https://matrix.org" target="_blank" rel="noopener">Matrix&lt;/a> de loin. Les seules fois où j’avais abordé ce standard, j’ai été très déçu à cause de la lenteur de celui-ci et aussi le fait que ce soit extrêmement intimidant au niveau sécurité.&lt;/p>
&lt;/div>
&lt;div id="beeper" class="paragraph">
&lt;p>&lt;span class="image center">&lt;img src="beeper.png" alt="beeper"/>&lt;/span>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Finalement, j’ai décidé de me lancer en entendant parler de &lt;a href="https://www.beeper.com" target="_blank" rel="noopener">Beeper&lt;/a> qui permettait de centraliser plein de protocoles au même endroit. J’ai été déçu de voir que c’était très payant pour une utilisation domestique. Et j’ai remarqué par mon don incroyable de lecture de la seule et unique page disponible que Beeper était une application basée sur Matrix et la notion de bridges. Donc, en théorie, on peut faire la même chose sans payer.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_quest_ce_que_matrix">Qu’est-ce que Matrix&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Matrix est un standard OpenSource pour construire une messagerie sécurisée en temps réel et décentralisée. Beaucoup de buzz words, on va expliquer tout ça.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>C’est un &lt;strong>standard&lt;/strong>, ce qui veut dire que Matrix n’est pas un logiciel mais simplement une liste de fonctionnalités à implémenter afin de supporter le protocole. C’est un peu comme si on parlait d’un mixeur, qui est la fonctionnalité, ce qui ne l’empêche pas d’avoir un nom donné par la marque ou par les utilisateurs. Le mixeur de mes parents s’appelle Bob.&lt;br/>
Une &lt;strong>messagerie sécurisée en temps réel&lt;/strong>, c’est assez simple à comprendre.&lt;br/>
Pour le côté &lt;strong>décentralisé&lt;/strong>, ça veut dire que un seul et unique serveur n’est pas souverain du réseau. Ainsi, installer un serveur chez vous permettra d’avoir accès au service sur votre réseau. Matrix implémente aussi un système pour faire dialoguer les serveurs entre eux, comme ça votre serveur ne reste pas dans son coin et pourra dialoguer avec le monde extérieur.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On a parlé plus haut des bridges, et ça c’est une des fonctionnalités de Matrix. Le principe est qu’on peut ajouter un genre de plugin qui joue le rôle d’interface avec quelque chose d’autre. Ouais c’est un peu abstrait, mais concrètement un bridge peut se charger en temps réel de relayer les messages d’une autre messagerie par exemple.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_installation_du_serveur">Installation du serveur&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>J’ai rassemblé tous mes efforts pour que tout fonctionne dans un dossier de mon installation NixOS. Il peut varier dans le temps, j’actualiserais le tutoriel et les liens vers ma configuration en fonction des updates.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_le_serveur_synapse">Le serveur Synapse&lt;/h3>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/blob/master/server/matrix/server.nix" target="_blank" rel="noopener">&lt;span class="image">&lt;img src="https://img.shields.io/badge/Gitlab-Synapse-orange" alt="Gitlab"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Tout commence d’abord par installer &lt;a href="https://matrix.org/docs/projects/server/synapse">Synapse&lt;/a> qui est un serveur Matrix. Matrix étant un standard, Synapse est une implémentation de celui-ci. Si vous êtes déjà perdu, relisez le point précédent ;)&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ici, NixOS nous a bien facilité la tache vu qu’une configuration est disponible, donc on peut aller très vite.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>services.matrix-synapse = {
enable = true;
server_name = &amp;#34;matrix.nicolasguilloux.eu&amp;#34;;
registration_shared_secret = &amp;#34;UnSecretTemporaire&amp;#34;;
# enable_registration = true;
listeners = [
{
port = 8008;
bind_address = &amp;#34;::1&amp;#34;;
type = &amp;#34;http&amp;#34;;
tls = false;
x_forwarded = true;
resources = [
{
names = [ &amp;#34;client&amp;#34; &amp;#34;federation&amp;#34; ];
compress = false;
}
];
}
];
};
# For the registration of a user
services.matrix-synapse.registration_shared_secret = &amp;#34;UnSecretTemporaire&amp;#34;;
environment.systemPackages = [ pkgs.matrix-synapse ];&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Il faut s’assurer que l’option &lt;code>server_name&lt;/code> correspond bien à l’adresse finale du serveur. C’est important pour faire dialoguer le monde extérieur avec notre instance. Si jamais vous vous lancez dans l’installation et que cette adresse est fausse, il faudra tout recommencer.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ici, on n’utilise qu’un seul port : le &lt;code>8008&lt;/code>. C’est celui conseillé dans la documentation. Vous remarquerez qu’il n’y a pas de SSL, c’est parce que mon serveur sera exposé à travers un Reverse Proxy géré par Nginx. On va voir ça après.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>L’option &lt;code>registration_shared_secret&lt;/code> est là uniquement pour enregistrer votre utilisateur administrateur. Il faudra bien penser à l’enlever, car elle permet de créer des utilisateurs un peu comme on veut en utilisant le dit mot de passe.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Et enfin, pas besoin d’importer le paquet de Synapse dans les ceux de système hormis pour l’inscription d’un nouvel utilisateur via un terminal.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_la_base_de_données">La base de données&lt;/h3>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/blob/master/server/matrix/database.nix" target="_blank" rel="noopener">&lt;span class="image">&lt;img src="https://img.shields.io/badge/Gitlab-BDD-orange" alt="Gitlab"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Il faudra aussi configurer une base de données PostgreSQL pour le serveur.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code># Manually configure PostgreSQL
# ref: https://www.foxypossibilities.com/2018/02/04/running-matrix-synapse-on-nixos/
services.postgresql.enable = true;
services.postgresql.initialScript = pkgs.writeText &amp;#34;synapse-init.sql&amp;#34; &amp;#39;&amp;#39;
CREATE ROLE &amp;#34;matrix-synapse&amp;#34; WITH LOGIN PASSWORD &amp;#39;${config.secrets.matrix.database}&amp;#39;;
CREATE DATABASE &amp;#34;matrix-synapse&amp;#34; WITH OWNER &amp;#34;matrix-synapse&amp;#34;
TEMPLATE template0
LC_COLLATE = &amp;#34;C&amp;#34;
LC_CTYPE = &amp;#34;C&amp;#34;;
&amp;#39;&amp;#39;;&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ici, mon mot de passe est défini bien au chaud dans la config. Pensez à mettre votre mot de passe. Vous pouvez aussi faire cette étape à la mano en allant tater &lt;code>sudo -u postgres psql&lt;/code>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_création_de_notre_admin">Création de notre admin&lt;/h3>
&lt;div class="paragraph">
&lt;p>Avant d’exposer sur Internet, on va déjà créer notre utilisateur admin puis désactiver la possibilité de s’enregistrer en utilisant les lignes de commandes. Comme ça, on ferme une porte !&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ici, rappelez vous la &lt;code>registration_shared_secret&lt;/code> mis plus haut et simplement tapez la commande suivante&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>register_new_matrix_user --shared-secret &amp;#34;UnSecretTemporaire&amp;#34; &lt;a href="http://localhost:8008" class="bare">http://localhost:8008&lt;/a>&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On suit donc tout ce qu’il nous dit comme il faut en prenant soin de mettre votre utilisateur Admin.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_le_reverse_proxy">Le Reverse Proxy&lt;/h3>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://gitlab.com/NicolasGuilloux/nixos-configuration/-/blob/master/server/matrix/nginx.nix" target="_blank" rel="noopener">&lt;span class="image">&lt;img src="https://img.shields.io/badge/Gitlab-Nginx-orange" alt="Gitlab"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va maintenant configurer notre Reverse Proxy pour qu’il puisse être accessible du monde extérieur. C’est important aussi pour pouvoir dialoguer avec les autres serveurs.&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>let
listenPort = port: ssl: {
addr = &amp;#34;0.0.0.0&amp;#34;;
port = port;
ssl = ssl;
};
in
{
# Open port
networking.firewall.allowedTCPPorts = [ 8448 ];
# Reverse proxy
services.nginx.virtualHosts.&amp;#34;matrix.nicolasguilloux.eu&amp;#34; = {
enableACME = true;
forceSSL = true;
listen = [
(listenPort 80 false)
(listenPort 443 true)
(listenPort 8448 true)
];
locations.&amp;#34;/_matrix&amp;#34; = {
proxyPass = &amp;#34;http://[::1]:8008&amp;#34;;
};
};
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ici, on voit que nous redirigeons tout vers notre serveur Synpase. On peut aussi voir qu’on utilise le port 8448. Il est important car c’est ce port qui est utilisé par la fédération des serveurs Matrix. Ainsi, un serveur lambda ira questionner notre serveur via ce port uniquement.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois tout installé, vous pouvez d’ailleurs &lt;a href="https://federationtester.matrix.org" target="_blank" rel="noopener">tester votre serveur&lt;/a> pour voir s’il est bien accessible par la fédération.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Si vous avez tout bien fait, normalement vous devez pouvoir vous connecter sur &lt;a href="https://app.element.io/#/login">Element.io&lt;/a>, modifier le serveur d’accueil (le fameux &lt;code>server_name&lt;/code>) et vous connecter.&lt;br/>
Vous remarquerez alors que votre pseudo est &lt;code>pseudo:server_name&lt;/code>. Par exemple, pour ma part, c’est &lt;code>nover:matrix.nicolasguilloux.eu&lt;/code>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_les_bridges">Les Bridges&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Une fois votre serveur fonctionnel, vous pouvez jouir de toutes les fonctionnalités de Matrix de base. Vous pouvez donc rejoindre des salons et discuter avec des personnes mêmes si elles ne sont pas sur votre serveur grâce à la magie de la fédération.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va maintenant pouvoir ajouter des bridges qui vont être les interfaces entre un autre protocole et celui de Matrix. En plus simple : ça va permettre d’envoyer des messages en utilisant Matrix vers des destinataires comme Signal ou encore Messenger.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ici, je ne vais passer en revue que les bridges que j’ai implémenté sur mon serveur. On notera que la plupart ont été conçu par la même personne et donc ont le préfix &lt;code>mautrix&lt;/code>. On peut donc constater qu’ils se configurent quasiment de la même manière.&lt;br/>
Je vais aussi essayer de trier l’ordre des bridges ci-dessous en fonction de leur difficulté à installer. Ca permettra de monter progressivement en difficulté.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="../mautrix-facebook">&lt;span class="image">&lt;img src="https://img.shields.io/badge/mautrix-facebook-blue" alt="mautrix facebook blue"/>&lt;/span>&lt;/a>
&lt;a href="../mautrix-telegram">&lt;span class="image">&lt;img src="https://img.shields.io/badge/mautrix-telegram-blue" alt="mautrix telegram blue"/>&lt;/span>&lt;/a>&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Mirint V2</title><link>https://nicolasguilloux.eu/articles/mirint-v2/</link><pubDate>Wed, 10 Mar 2021 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/mirint-v2/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/mirint-v2/screen.jpg" alt="Featured image of post Mirint V2" />&lt;div class="paragraph">
&lt;p>J’ai décidé de revoir mon &lt;a href="https://nicolasguilloux.eu/articles/mirint-v1">miroir intelligent&lt;/a> pour plusieurs raisons :&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>J’ai domotisé ma maison, et avoir un affichage des différents capteurs serait vraiment un plus&lt;/p>
&lt;/li>
&lt;li>
&lt;p>La page web affichée était fait à la main, alors que des solutions bien plus jolies existent comme &lt;a href="https://magicmirror.builders/" target="_blank" rel="noopener">MagicMirror&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Le miroir était beaucoup trop épais, il sortait du mur d’une 10aine de centimètres&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Il était moche&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Il était beaucoup trop lourd, impossible de l’installer sur un mur sans mettre 1 ou 2 chevilles&lt;/p>
&lt;/li>
&lt;li>
&lt;p>L’écran mettait trop de temps à s’allumer, c’est dommage pour quelque chose qui doit donner des informations de manière spontanée de prendre 10 secondes les afficher&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Autre chose qui en découle, mais on pouvait laisser l’écran allumer, mais il consommait beaucoup trop&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour toutes ces raisons, j’ai décidé de le démonter pour en faire une nouvelle version.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_matériel">Matériel&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_ecran">Ecran&lt;/h3>
&lt;div class="paragraph">
&lt;p>Je ne garderais par l’écran car c’est la principale raison pour laquelle le miroir n’était pas satisfaisant. Comme c’est une ancienne télévision, tout était prévu pour avoir de l’espace derrière l’écran et que celle-ci soit posée sur un meuble. On peut le voir notamment avec les ports HDMI qui sont à la perpendiculaire de la dalle, son épaisseur et son poids.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;span class="image">&lt;img src="screen_display.jpg" alt="Ecran"/>&lt;/span>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>J’ai réussi à récupérer un écran LCD d’un ordinateur portable et j’ai commandé une carte d’aquisition pour le modèle de l’écran de ~13€ qui fera l’interface entre la sortie HDMI du Rapsberry Pi et la dalle LCD. Le principal intérêt de récupérer un écran comme celui-ci est qu’il a été prévu pour ne pas consommer car étant à l’origine dans un appareil mobile, que son poids et son épaisseur est vraiment faible et que cela permet de déporter la dite carte où on peut pour économiser encore une fois de l’espace et réduire l’épaisseur du miroir.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>L’autre intérêt est le temps pour s’allumer. Il est quasi immédiat, c’est ainsi que sont utilisés les écrans d’ordinateurs portables. Vous verrez rarement un ordinateur mettre 10 secondes à s’allumer lorsque vous le sortez de veille, ou alors c’est votre OS qui prend son temps et non l’écran.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Et enfin la sécurité : je suis toujours plus à l’aise quand je ne travaille pas avec des tensions mortelles. Aussi, l’écran LCD et sa carte sont alimentés en 12V, ce qui permettra de sortir l’alimentation hors du miroir. Il faudra néanmoins prévoir un abaisseur de tension pour alimenter le Raspberry Pi en 5V.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_raspberry_pi">Raspberry Pi&lt;/h3>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>Parlons du Raspberry Pi. Il s’avère que je pensais avoir un Raspberry Pi 2, mais en fait c’est le premier modèle. Il est donc extrêmement lent, il n’a clairement pas les reins pour produire un affichage rapide qui pourrait avoir des animations fluides. Aussi, il faudra que je change ce composant, il n’est pas approprié. Pour le moment, j’ai rien d’autre sous la main, et donc je l’utilise comme navigateur avec MagicMirror hébergé à un autre endroit. Dans la suite, je ferais comme si MagicMirror était hébergé sur le Raspberry Pi&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le Raspberry Pi va héberger le logiciel qui va nous permettre de facilement intégrer différents modules pour avoir l’affichage le plus complet possible : &lt;a href="https://magicmirror.builders/" target="_blank" rel="noopener">MagicMirror&lt;/a>. C’est un logiciel spécialement conçu ce qu’on veut faire. Vous pouvez rajouter des plugins pour avoir toute sorte d’information sur l’écran. Comme tout côté logiciel a été fait, on ne va pas beaucoup aborder la configuration de MagicMirror hormis le fait d’avoir une installation fonctionnelle.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Lola</title><link>https://nicolasguilloux.eu/articles/lola/</link><pubDate>Sun, 18 Mar 2018 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/lola/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/lola/screenshot.jpg" alt="Featured image of post Lola" />&lt;div class="paragraph">
&lt;p>Lola est une extension firefox qui permet de styliser votre nouvel onglet. C’est ma première approche vers les extensions des navigateurs.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Elle est fortement inspirée de l’extension &amp;#34;Momentum&amp;#34; mais ajoute des fonctionnalités qui me plaisent :
* La météo
* Les raccourcis en bas à gauche sous forme d’icones
* Des notifications en bas à droite&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://github.com/NicolasGuilloux/Lola" target="_blank" rel="noopener">Extension Firefox&lt;/a> - &lt;a href="https://github.com/NicolasGuilloux/Lola" target="_blank" rel="noopener">Github&lt;/a>&lt;/p>
&lt;/div></description></item><item><title>Mirint</title><link>https://nicolasguilloux.eu/articles/mirint-v1/</link><pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/mirint-v1/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/mirint-v1/cover.jpg" alt="Featured image of post Mirint" />&lt;div class="paragraph">
&lt;p>Le miroir intelligent est une petite interface qui devrait, le matin et le soir (ou à vrai dire, à chaque fois que vous allez dans la salle de bain), vous donner des informations pertinentes.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le but est de se dispenser de vérifier son Smartphone en affichant les choses à faire dans la journée, la météo et quelques news. Et dans un soucis d’ergonomie, pas besoin d’un bouton pour l’activer : un capteur de proximité se chargera de le réveiller quand vous le regardez.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour l’instant, le projet n’en est qu’à un stade de prototype non fini. Il n’est toutefois pas abandonné.
Après l’achèvement des premières fonctionnalités, le travail suivant sera d’implémenter une reconnaissance vocale.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_matériel">Matériel&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Mirint regroupe différents appareils &amp;#34;recyclés&amp;#34; : ils ne servaient plus, donc je me suis servi.&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>Ecran de télévision LCD&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Raspberry Pi 2 et son alimentation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Câble HDMI&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Un coffret&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Un film miroir sans teint&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Une plaque de plexiglas&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Du fil et de quoi souder&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>La première étape a été de dépioter le téléviseur. Afin que le miroir soit le plus fin possible, il faut enlever toute la partie protection plastique pour ne garder que la dalle et les circuits du téléviseur qui se divisent souvent en deux parties : un circuit d’alimentation où on relit l’appareil au secteur et un circuit d’entrées/sorties où vous branchez HDMI etc.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Il est important de &lt;strong>ne pas toucher le circuit d’alimentation&lt;/strong> quand le système est sous tension ! Il y a risque d’électrisation voire électrocution !&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;span class="image">&lt;img src="tele_dessus.jpg" alt="Vue de dessus"/>&lt;/span>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le Raspberry Pi est relié donc en HDMI au téléviseur. On pourrait auto-alimenter le RPi grâce au port USB du téléviseur, mais il sera tributaire de sa puissance. De plus, si le téléviseur est éteint, il y a de grandes chances que sur la plus part des téléviseur, le port USB soit désactivé. On opte donc pour une alimentation séparée.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le coffret a été raboté afin de pouvoir placer le téléviseur sur ses rebords et donc avoir la dalle sur le même plan horizontal que les bords du coffret. Il faudra aussi faire en sorte que ces mêmes bords ainsi que ceux du téléviseur soient noirs (peinture ou scotch noir).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;span class="image">&lt;img src="tele_dos.jpg" alt="Dos de la télé"/>&lt;/span>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>La plaque de plexiglas a été découpée avec les dimensions extérieures du coffret afin qu’elle couvre toute la surface.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le film miroir a été collé sur la surface qui sera vers l’intérieur du coffret afin d’éviter toute dégradation et rentrée de lumière. Pour le mettre en place :&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Bien laver le plexiglas,&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mettre de l’eau savoneuse sur la surface à coller,&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Enlever le film protecteur du revêtement miroir,&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Placer le film progressivement sur la surface en raclant avec une carte afin de chasser les bulles d’air&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Une fois placé et bien seché, couper l’excédent de film&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour ma part, j’ai percé puis fraisé le plexiglas pour le visser sur le coffret.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Par ailleurs, on veut pouvoir allumer le téléviseur sans appuyer physiquement sur le bouton &amp;#34;Allumer&amp;#34; car ça contraint à démonter le miroir à chaque fois. Ainsi, on regarde la tension appliquée aux bornes de ce bouton poussoir. Généralement, il y a 4 pattes donc pour peut vérifier avec deux bornes en diagonale.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;span class="image">&lt;img src="btn_power.jpg" alt="Boutons"/>&lt;/span>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois trouvé (pour ma part 3,3V), on soude deux fils : un qui ira à la masse du Raspberry Pi et l’autre à un de ses nombreux GPIO, j’ai choisi le n°7. Pour voir la partie logicielle, rendez vous un peu plus bas au paragraphe &amp;#34;Contrôle du téléviseur&amp;#34;.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_logiciel">Logiciel&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;strong>La partie logicielle est obsolète, puisque maintenant il y a &lt;a href="https://magicmirror.builders/" target="_blank" rel="noopener">MagicMirror&lt;/a> qui propose de faire tout ce que j’ai pu proposer.&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Dans un premier temps, veillez à bien configurer votre téléviseur pour s’allumer lorsque qu’on le branche et de choisir la source HDMI par défaut. Vous pouvez aussi configurer la profondeur du noir : plus il sera profond plus le rendu sera de qualité.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>De plus, vous pouvez configurer le téléviseur pour ne pas s’éteindre. Une amélioration sera à prévoir pour économiser de l’énergie.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Venons au Raspberry qui sera le cerveau de notre miroir. J’ai choisi de faire l’affichage en HTML sur un serveur Web qui sera pour ma part plus facile à maintenir. Toutefois, avant parler du coeur du projet, il faut configurer notre Raspberry. Je me suis basé sur l’OS Raspbian Jessie Lite. Je pars du principe que les périphériques branchés fonctionnent correctement (comme la carte WiFi de votre RPi).&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_connexion_au_wifi">Connexion au Wifi&lt;/h3>
&lt;div class="paragraph">
&lt;p>Commençons par chercher le SSID de votre réseau (son petit nom en fait) en scannant ce que le RPi reçoit : &lt;code>sudo iwlist wlan0 scan&lt;/code>. Cherchez le SSID de votre réseau et notez le dans un coin de votre tête.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On va maintenant modifier les paramètres des réseaux WiFi &lt;code>sudo nano /etc/wpa_supplicant/wpa_supplicant.conf&lt;/code> puis rentrez les informations comme suit à la fin du fichier (ou dans le champ correspondant s’il existe déjà la variable) :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>network={
ssid=&amp;#34;votre SSID&amp;#34;
psk=&amp;#34;votre mot de passe&amp;#34;
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>ATTENTION : Votre mot de passe est stocké en clair.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ensuite, on valide nos changements en effectuant ce petit bout de code : &lt;code>sudo wpa_cli reconfigure&lt;/code>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On aura besoin d’une interface graphique et de mettre à jour le bousin. On installe donc un serveur X et on met à jour le système (et un petit brin de ménage au cas ou) avec la ligne suivante :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>sudo apt-get update
sudo apt-get --no-install-recommends install xserver-xorg xserver-xorg-video-fbdev xinit pciutils xinput xfonts-100dpi xfonts-75dpi xfonts-scalable x11-xserver-utils unclutter
sudo apt-get dist-upgrade
sudo apt-get autoremove&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_paramétrage_du_raspberry_pi">Paramétrage du Raspberry Pi&lt;/h3>
&lt;div class="paragraph">
&lt;p>On va maintenant aller dans les configurations de base du RPi : &lt;code>sudo raspi-config&lt;/code>. Cela vous amènera sur l’interface &amp;#34;graphique&amp;#34; suivante :&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;span class="image">&lt;img src="raspi-config.jpg" alt="Raspi config"/>&lt;/span>]&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On configure comme ça nous plait en changeant le mot de passe et les options de localisation. On choisit ensuite le menu Interfacing Option pour activer le SSH afin de piloter le miroir à distance.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Enfin, on appuie 2 fois sur Tab pour sélectionner &amp;#34;Finish&amp;#34; et on accepte de redémarrer notre Raspberry Pi.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_rotation_de_lécran">Rotation de l’écran&lt;/h3>
&lt;div class="paragraph">
&lt;p>Une rotation de l’écran peut être souhaitable suivant le sens de votre miroir. Il nous faut alors modifier un fichier en suivant cette commande : &lt;code>sudo nano /boot/config.txt&lt;/code> et on y ajoute la ligne &lt;code>display_rotate = 1&lt;/code>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Voici les différentes options :&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>0 : Orientation normale&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1 : 90 degrés&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2 : 180 degrés&lt;/p>
&lt;/li>
&lt;li>
&lt;p>3 : 270 degrés&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_configuration_de_linterface_graphique">Configuration de l’interface graphique&lt;/h3>
&lt;div class="paragraph">
&lt;p>D’abord, on ajoute un nouvel utilisateur pour se connecter avec lors des connexions SSH. On lance la commande &lt;code>sudo adduser NouvelUtilisateur&lt;/code>. On répond gentillement à tout ce qu’il nous demande.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On souhaite maintenant charger juste un navigateur. Il faut donc choisir votre navigateur préféré, j’ai choisi Chromium. Pour l’installer : &lt;code>sudo apt-get install chromium-browser&lt;/code>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ensuite, pour lancer le navigateur en plein écran sur GitHub, il faut suivre la commande suivante :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>startx /usr/bin/chromium-browser https://github.com/ --window-size=1080,1920 --start-fullscreen --kiosk --incognito -- -nocursor&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Il faut prendre garde à l’orientation de l’écran et sa résolution. Pour ma part, je l’avais mis format portrait en full HD.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour l’ajouter au démarrage, édite un fichier par la commande &lt;code>nano ~/.bashrc&lt;/code> sous l’utilisateur &amp;#34;pi&amp;#34; et ajoute la commande.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Il faudra maintenant arrêter l’écran de veille en éditant le fichier lightdm.conf par la commande suivant &lt;code>sudo nano /etc/lightdm/lightdm.conf&lt;/code> et on ajoute &lt;code>xserver-command=X -s 0 dpms&lt;/code>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_pilotage_à_distance">Pilotage à distance&lt;/h3>
&lt;div class="paragraph">
&lt;p>Notre miroir n’a ni clavier, ni souris. Et rien n’est moins pratique que de contrôler le miroir par la pensée. On va donc se servir du protocole VNC qui va nous servir à piloter l’interface graphique à distance, comme avec le SSH (ils peuvent d’ailleurs être liés). Pour cela, on installe x11vnc : &lt;code>sudo apt-get install x11vnc&lt;/code>. Ensuite, on peut lancer 1 session avec &lt;code>x11vnc -auth guess&lt;/code> une fois startx lancé par SSH.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_contrôle_du_téléviseur">Contrôle du téléviseur&lt;/h3>
&lt;div class="paragraph float-right">
&lt;p>&lt;span class="image">&lt;img src="gpio.png" alt="GPIO"/>&lt;/span>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Cela découle directement du soudage du bouton. Dans un premier, on installe WiringPi en suivant les instructions de ce &lt;a href="http://wiringpi.com/download-and-install/">lien&lt;/a>. Cela nous permettra d’utiliser facilement les GPIO ! Pour plus d’informations, je vous laisse checker le &lt;a href="http://blog.idleman.fr/raspberry-pi-06-utiliser-le-gpio-et-interagir-avec-le-monde-reel/">blog d’Idleman&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Une fois installé, on peut commencer les festivités. On paramètre d’abord le GPIO pour être en mode &amp;#34;out&amp;#34; : &lt;code>gpio mode 7 out&lt;/code>. Comme je l’ai dis précedemment, j’ai choisi le GPIO 7 (en suivant le schéma joint). On peut ensuite piloter le port en utilisant &lt;code>gpio write 7 bit&lt;/code> en remplaçant &amp;#34;bit&amp;#34; par 1 pour du 3,3V ou 0 pour du 0V.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>On peut voir que le bouton réagit par front descendant en s’amusant à changer ces valeurs (donc pour simuler le bouton appuyé, on place le GPIO à 0).&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ainsi, pour simuler l’appui du bouton, on utilise la ligne suivante :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>gpio write 7 0 &amp;amp;&amp;amp; sleep 1 &amp;amp;&amp;amp; gpio write 7 1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Pour paramétrer le GPIO en mode out et à l’état 1 (repos du bouton), il nous faut éditer le fichier /home/pi/.bashrc et rajouter les lignes suivantes :&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code>gpio mode 7 out
gpio write 7 1&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Ainsi à chaque démarrage, on configure le GPIO 7 en mode Out et à l’état 1.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Cafetière à Induction Domotisée</title><link>https://nicolasguilloux.eu/articles/cid/</link><pubDate>Sun, 25 Jun 2017 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/cid/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/cid/photo.jpg" alt="Featured image of post Cafetière à Induction Domotisée" />&lt;div class="paragraph">
&lt;p>La Cafetière à Induction Domotisée, aka CID, est une cafetière avec plus d’un atout dans sa poche.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le but de ce projet était de faire du café rapidement, silencieusement avec la même qualité que les cafetières à dosette. En bref, combler les lacunes de ces dernières en ajoutant une partie domotique.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Le projet a été commencé par mes soins, puis poursuivi dans le cadre des projets de deuxième année de l’ENSEA avec &lt;a href="https://www.linkedin.com/in/loirevalentin/" target="_blank" rel="noopener">Valentin Loire&lt;/a>. Nous poursuivons jusqu’à ce jour le développement.&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://nicolasguilloux.github.io/cid/" target="_blank" rel="noopener">Voir sa page de présentation&lt;/a>&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/DSbic6T9NO8"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;/div></description></item><item><title>Douglas</title><link>https://nicolasguilloux.eu/articles/douglas/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/douglas/</guid><description>&lt;img src="https://nicolasguilloux.eu/articles/douglas/cover.png" alt="Featured image of post Douglas" />&lt;p>Douglas est une enceinte Bluetooth Low-Cost. Une batterie pour portable recyclée, à peu près 15€ de l&amp;rsquo;huile de coude et vous voilà avec un objet essentiel pour toute sortie entre amis.
Pourquoi l&amp;rsquo;ourson ? Parce que c&amp;rsquo;est mignon, ça protège bien le matériel qu&amp;rsquo;il y a dedans et que c&amp;rsquo;est original.&lt;/p>
&lt;p>Douglas est fonctionnel, mais toujours en développement. En effet, je souhaite y apporter quelques fonctionnalités comme la visualisation de la charge de la batterie, le réveil de l&amp;rsquo;enceinte sans besoin de bouton physique (hormis pour l&amp;rsquo;appairage).&lt;/p>
&lt;h1 id="version-1">Version 1&lt;/h1>
&lt;p>Douglas a surtout pour principe de ne pas couter cher en achetant le minimum possible. Ainsi, seuls les objets ayant un lien dans la liste suivante ont été acheté, le reste étant de la récupération.&lt;/p>
&lt;ul>
&lt;li>Une batterie Li-Ion&lt;/li>
&lt;li>Un amplificateur symétrique&lt;/li>
&lt;li>Deux haut-parleurs 3W&lt;/li>
&lt;li>Un circuit de charge pour batterie Li-Ion&lt;/li>
&lt;li>Un module Bluetooth A2DP (le BK800L)&lt;/li>
&lt;li>Des résistances de 10kΩ, de des boutons poussoirs&lt;/li>
&lt;li>Des fils, de l&amp;rsquo;étain et un fer à souder&lt;/li>
&lt;li>Une plaquette pour souder&lt;/li>
&lt;/ul>
&lt;p>On en a en tout pour une 15aine d&amp;rsquo;euros, on s&amp;rsquo;en sort donc pas trop mal. Il reste maintenant à souder tous les composants ensembles afin que tout fonctionne correctement.&lt;/p>
&lt;p>Les choses sérieuses arrivent et il faudra être bien concentré pour la suite des évènements. En effet, le module Bluetooth est un enfer à souder pour peu qu&amp;rsquo;on n&amp;rsquo;ai ni fil à wrapper, ni un fer à souder digne de ce nom&amp;hellip; J&amp;rsquo;ai donc fait au possible.
J&amp;rsquo;ai dénudé un fil multibrin pour découper des brins de longueur 3cm. J&amp;rsquo;ai ensuite soudé chaque brin sur les cosses du module. C&amp;rsquo;est fastidieux et ça a tendance à déconner. Le meilleur aurait de faire un PCB, mais quand on a pas le matériel, on se débrouille quand même !&lt;/p>
&lt;p>Je n&amp;rsquo;ai pas utilisé toutes les pins mais seulement les suivantes : 1, 2, 4, 5, 6, 7, 12, 16, 17, 25, 26, 29, 32.&lt;/p>
&lt;p>J&amp;rsquo;ai préféré relier toutes les masses (GND sur le schéma) à la masse pour éviter au maximum les interférences. Je ne sais pas si c&amp;rsquo;est utile, mais ça me rassure. De plus, je n&amp;rsquo;ai choisi que les pins qui m&amp;rsquo;intéressaient à savoir les boutons, le son et l&amp;rsquo;alimentation. On peut très bien utiliser les pins Rx/Tx pour renommer le module Bluetooth par exemple (et remplacer cet affreux nom &amp;ldquo;BK8000L&amp;rdquo;).&lt;/p>
&lt;p>Place maintenant au montage sur la carte. On prend une petite carte qui acceptera tous les composants.
On colle dans un premier temps la batterie sur le circuit. Ensuite, on soude un à un les composants comme le stipule le schéma suivant :&lt;/p>
&lt;p>&lt;img src="https://nicolasguilloux.eu/articles/douglas/schema.png"
width="947"
height="536"
srcset="https://nicolasguilloux.eu/articles/douglas/schema_hudedf8d59ca883a4390b4d9a69f859e5e_173385_480x0_resize_box_3.png 480w, https://nicolasguilloux.eu/articles/douglas/schema_hudedf8d59ca883a4390b4d9a69f859e5e_173385_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Schema"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>Assurez vous que les soudures soient bien faites afin de ne pas avoir de mauvaises surprises. De plus, prenez garde au soudage du module Bluetooth qui est extrêmement fastidieux compte tenu des petits espaces disponibles, d&amp;rsquo;où l&amp;rsquo;utilité des fils à wrapper.&lt;/p>
&lt;p>Cela donne le résultat suivant. Vous avez théoriquement 4 fils non-reliés qui sont dédiés aux speakers. J&amp;rsquo;ai mis un fil supplémentaire qui est un câble USB directement soudé aux bornes du circuit de charge. J&amp;rsquo;ai donc un port femelle micro-USB ou un câble USB mâle sortant pour recharger facilement.&lt;/p>
&lt;p>&lt;img src="https://nicolasguilloux.eu/articles/douglas/montage.jpg"
width="1152"
height="955"
srcset="https://nicolasguilloux.eu/articles/douglas/montage_hu86b862263dc8a5c880bef30b8ea0599e_260275_480x0_resize_q75_box.jpg 480w, https://nicolasguilloux.eu/articles/douglas/montage_hu86b862263dc8a5c880bef30b8ea0599e_260275_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="Montage"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="289px"
>&lt;/p>
&lt;p>Pour les enceintes, il a fallu faire 2 caisses de résonnance adaptée aux haut-parleurs et aux dimensions de mon ourson. J&amp;rsquo;ai pris des tubes en carton trouvés par-ci par-là. A vous d&amp;rsquo;adapter comme vous le voulez ou pouvez afin d&amp;rsquo;avoir une bonne caisse de résonnance. Il n&amp;rsquo;y a pas de règle particulière si ce n&amp;rsquo;est que de bien fixer les HP pour éviter toute fuite d&amp;rsquo;air ou vibration.&lt;/p>
&lt;p>&lt;img src="https://nicolasguilloux.eu/articles/douglas/speaker.jpg"
width="849"
height="1045"
srcset="https://nicolasguilloux.eu/articles/douglas/speaker_hu704a7857007f13a26bf776070e1a4b58_133177_480x0_resize_q75_box.jpg 480w, https://nicolasguilloux.eu/articles/douglas/speaker_hu704a7857007f13a26bf776070e1a4b58_133177_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="Speakers"
class="gallery-image"
data-flex-grow="81"
data-flex-basis="194px"
>&lt;/p>
&lt;h1 id="pour-une-prochaine-version">Pour une prochaine version&lt;/h1>
&lt;p>Douglas v1 souffrait de quelques petits problèmes ergonomiques.&lt;/p>
&lt;ul>
&lt;li>Quand quelqu&amp;rsquo;un le serrait dans ses bras (ce qui arrivait souvent), cela pouvait appuyer sur le bouton situé au niveau du ventre. Un appui long redémarre le module ce qui est frustrant lorsque de la musique est en route.&lt;/li>
&lt;li>Les boutons pour changer de chanson n&amp;rsquo;étaient quasiment jamais utilisés.&lt;/li>
&lt;li>Les boutons volumes seraient souhaitables mais pourraient ne pas être utilisés.&lt;/li>
&lt;li>Changer le volume sur le module s&amp;rsquo;effectue localement. Hors on pourrait souhaiter qu&amp;rsquo;un changement de volume sur Douglas se transmette au Smartphone afin que le volume s&amp;rsquo;actualise sur ce dernier.&lt;/li>
&lt;li>Le circuit de charge n&amp;rsquo;est pas facile d&amp;rsquo;accès.&lt;/li>
&lt;li>La carte en elle même n&amp;rsquo;est pas prévue pour une longue durée de vie, vu les soudures.&lt;/li>
&lt;/ul>
&lt;p>Ce sont des petits problèmes qui n&amp;rsquo;en sont pas. Je pinaille, mais c&amp;rsquo;est suffisant pour se lancer dans une version 2 qui pourrait résoudre certains de ces problèmes !&lt;/p>
&lt;p>De plus, j&amp;rsquo;aimerai bien passer pour la version 2 sur du 5W afin d&amp;rsquo;avoir plus de puissance.&lt;/p>
&lt;p>Autre chose qui m&amp;rsquo;embête, c&amp;rsquo;est le nom du module Bluetooth. En effet, il diffuse le nom &amp;ldquo;BK8000L&amp;rdquo;. Ce serait super chouette de pouvoir le modifier en Douglas par exemple.&lt;/p>
&lt;p>Un petit plus serait aussi de pouvoir rediriger le son vers une sortie jack. J&amp;rsquo;ai pensé à ça quand il y a une petite sono sans bluetooth, et qu&amp;rsquo;on souhaite quand même profiter du sans fil sans installation bancale.&lt;/p>
&lt;p>De la même manière, pouvoir brancher un câble Jack dans Douglas pour bénificier de ses haut-parleurs pourrait être sympathique. Dans le module ci-dessus du moins, les ports Aux_L et Aux_R (20 et 19) ne sont malheureusement pas déportés. Si nous voulons les utiliser, il faudra souder deux fils sur la carte ce qui peut s&amp;rsquo;avérer laborieux et dangereux pour la carte.&lt;/p>
&lt;p>&lt;img src="https://nicolasguilloux.eu/articles/douglas/aux_module.png"
width="700"
height="542"
srcset="https://nicolasguilloux.eu/articles/douglas/aux_module_huc7dc6da2c914796a17e11d4a73bf87d0_568546_480x0_resize_box_3.png 480w, https://nicolasguilloux.eu/articles/douglas/aux_module_huc7dc6da2c914796a17e11d4a73bf87d0_568546_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Aux module"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="309px"
>&lt;/p>
&lt;p>Enfin, je souhaiterai oublier les petites batteries Li-Ion si possible. En effet, dans une des enceintes que j&amp;rsquo;avais conçu, l&amp;rsquo;une d&amp;rsquo;elle avait gonflé et comme elles ne sont pas protégées, je ne suis pas rassurer.&lt;/p>
&lt;p>Je préfère utiliser des batteries externes car elles sont généralement protégées par un boitier, et ont une bien plus grande capacité.&lt;/p></description></item><item><title>Yana</title><link>https://nicolasguilloux.eu/articles/yana/</link><pubDate>Thu, 24 Oct 2013 00:00:00 +0000</pubDate><guid>https://nicolasguilloux.eu/articles/yana/</guid><description>&lt;img src="https://raw.github.com/Etsuni/YANA/master/presentation.png" alt="Featured image of post Yana" />&lt;p>YANA est une interface domotique développée par &lt;a class="link" href="https://github.com/ldleman" target="_blank" rel="noopener"
>Idleman&lt;/a>.
L&amp;rsquo;application Android permettait de dicter des ordres afin de déclencher les actions côté serveur. Elle servait donc d&amp;rsquo;interface portable pour controller l&amp;rsquo;installation.&lt;/p>
&lt;p>A cause de mes études, j&amp;rsquo;ai dû mettre de côté le développement de l&amp;rsquo;application pour au final l&amp;rsquo;abandonner. En effet, le serveur a beaucoup évolué sans que je puisse poursuivre les mises à jour. Une autre personne a continué le développement et est donc en charge par la suite de maintenir.&lt;/p>
&lt;p>Je remercie :&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/ldleman" target="_blank" rel="noopener"
>Valentin Carruesco&lt;/a> pour le développement de YANA serveur.&lt;/li>
&lt;li>Alexandre Roland pour la reprise du développement de YANA Android.&lt;/li>
&lt;/ul></description></item></channel></rss>