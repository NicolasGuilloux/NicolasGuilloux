[{"content":" La certification locale est très utile majoritairement pour du développement local. Il s’agit de fournir un certificat pour chaque domaine hébergé sur la machine, et que la fameuse page vous disant que le site est dangereux disparaisse.\nComment fonctionne un certificat Tout d’abord, un certificat sert à garantir l’authenticité d’un site par l’intermédiaire une autorité de confiance abrégée CA pour Certification Authority. Je vais faire un exemple.\nJe souhaite certifier que le site blog.nicolasguilloux.eu est à moi auprès d’un CA (par exemple Let’s Encrypt). Il va alors se passer plusieurs choses successivement :\nJe créé un couple de clé privée et clé publique.\nJe demande au CA de me donner un challenge pour qu’il vérifie que je contrôle bien l’adresse en question\nGénéralement, c’est un texte que l’on doit fournir à une URL précise (par exemple mettre le texte ed98 dans l’URL https://blog.nicolasguilloux.eu/8303) et de le signer avec ma clé privée.\nLe CA vérifie alors que le challenge est OK en déchiffrant le contenu de ladite page avec la clé publique qu’on lui fournit.\nLe CA enregistre alors cette clé publique et la fournie à qui veut vérifier la certification du site blog.nicolasguilloux.eu\nAinsi, une personne lambda qui accède au site demande la clé publique au CA et vérifie le certificat fourni par le site avec chaque requête HTTPS avec celle-ci pour vérifier que je suis bien le propriétaire du site.\nPour plus d’information, vous pouvez consulter la documentation de Let’s Encrypt. L’image précédente est d’ailleurs tirée de cette page.\nNotre certification custom Quand on demande une page https sans fournir de certificat, notre navigateur nous met en garde que ce n’est pas sécurisé, car il ne peut pas vérifier la source des informations données. On va donc y remédier en créant un certificat par nous même, et en disant au système que l’autorité de confiance que nous avons créée est justement de confiance.\nOn remarque qu’on ne s’occupera pas de la partie challenge, qui est uniquement là pour que le CA nous croit notre légitimité. Ici, on est légitime, on détient de le système. Et le CA, c’est nous, on fait ce qu’on veut !\nOn va créer une dérivation qui va générer les certificats grâce à la liste des domaines qu’on lui aura fournis ainsi que l’éventuelle autorité de certification qu’on lui aura donné.\n{ stdenv , mkcert , domains ? [ \u0026#34;local\u0026#34; \u0026#34;*.local\u0026#34; ] , authority ? null }: let domainsToString = builtins.concatStringsSep \u0026#34; \u0026#34; ( builtins.map (domain: \u0026#34;\\\u0026#34;${domain}\\\u0026#34;\u0026#34;) domains ); in stdenv.mkDerivation rec { name = \u0026#34;local-certificates\u0026#34;; dontUnpack = true; installPhase = \u0026#39;\u0026#39; # Create the directories mkdir -p $out/ssl/authority; \u0026#39;\u0026#39; + if authority != null then \u0026#34;cp ${authority} $out/ssl/authority/rootCA.pem\u0026#34; else \u0026#34;\u0026#34; + \u0026#39;\u0026#39; # Generate the certificates CAROOT=\u0026#34;$out/ssl/authority\u0026#34; \\ ${mkcert}/bin/mkcert \\ -cert-file $out/ssl/local-cert.pem \\ -key-file $out/ssl/local-key.pem \\ ${domainsToString} \u0026#39;\u0026#39;; } L’intégration dans le système Regardons maintenant son intégration dans la configuration générale de NixOS.\n{ config, lib, pkgs, ... }: let localCerts = pkgs.callPackage ./local-certs.nix { domains = config.networking.hosts.\u0026#34;127.0.0.1\u0026#34;; # authority = ./rootCA.pem; }; in { # Add certificates systemwide security.pki.certificateFiles = [ (localCerts + \u0026#34;/ssl/authority/rootCA.pem\u0026#34;) ]; # Add local certificates services.traefik.dynamicConfigOptions.tls = { certificates = [ { certFile = \u0026#34;${localCerts}/ssl/local-cert.pem\u0026#34;; keyFile = \u0026#34;${localCerts}/ssl/local-key.pem\u0026#34;; } ]; stores.default.defaultCertificate = { certFile = \u0026#34;${localCerts}/ssl/local-cert.pem\u0026#34;; keyFile = \u0026#34;${localCerts}/ssl/local-key.pem\u0026#34;; }; }; } On peut déjà constater que je build la dérivation précédemment mentionnée afin de pouvoir l’exploiter ensuite. Comme domaine, je donne tous ceux qui renvoient vers mon localhost. Je brasse large, mais c’est plus simple ainsi.\nOn remarque aussi que j’ai commenté le authority. Si vous avez déjà créé l’autorité, vous pouvez l’utiliser sinon une sera créée pour vous. Cependant, cela peut poser problème si vous ne redémarrez pas entièrement votre système. En effet, si par exemple vous lancez Chrome, celui-ci récupèrera les autorités de votre système lors du démarrage. Ainsi, si les certificats locaux sont reconstruits, l’autorité aussi et Chrome n’aura pas la nouvelle autorité tout juste créée, du moins jusqu’à son prochain redémarrage.\nOn remarque donc qu’on ajoute le rootCA.pem dans les autorités du système. Ainsi, le système croira tous les certificats émis par cette autorité, c’est-à-dire la notre.\nEn prime, j’ai ajouté une configuration pour dire à Traefik d’associer le certificat généré par défaut. C’est un exemple et certaines personnes pourraient vouloir l’implémenter autrement.\nEt voilà ! Vous avez dorénavant une certification locale qui se régénère dès que vous ajoutez un site dans vos hosts.\n","date":"2022-07-21T00:00:00Z","image":"https://nicolasguilloux.eu/articles/local-certification/cover_hu88596287000f60de4446d87d742fbc09_66720_120x120_fill_box_smart1_3.png","permalink":"https://nicolasguilloux.eu/articles/local-certification/","title":"Certification locale"},{"content":" J’ai jonglé entre 3 proxies récemment afin de pouvoir facilement rediriger des requêtes vers les services appropriés, que ce soit en utilisant Docker ou en utilisant des services exposant des ports.\nLet’s get started J’ai expérimenté les proxies suivants dans l’ordre chronologique. Je vais passer en revue pourquoi je les ai utilisés, et pourquoi je les ai aussi abandonnés. Il n’y en a pas nécessairement de meilleurs que d’autres, c’est juste que chacun trouve chaussure à son pied !\nJ’avais aussi utilisé une configuration qui permettait de facilement jongler entre les différents services en adaptant le module sans pour autant rajouter de configuration. C’est d’ailleurs l’un des gros avantages de NixOS : pouvoir dissocier la configuration de l’implémentation. Vous pouvez voir le code ici.\nPour des raisons de facilité, on va utiliser l’exemple d’un site web qui serait à l’adresse blog.nicolasguilloux.eu et qui serait disponible en local sur le port 8080. Bien entendu, on souhaite que le site soit en https.\nNginx C’est le premier proxy que j’ai utilisé, car c’est le serveur web que j’utilisais et qui permettait de facilement mettre en place cette fonctionnalité. C’est aussi le serveur web majoritairement utilisé.\nLa première chose à faire est de configurer le Acme challenge ainsi que 4 optimisations recommandées pour Nginx. Le premier servira bien entendu à générer automatiquement le certificat HTTPS pour notre site.\n# ACME Challenge security.acme.acceptTerms = true; security.acme.defaults.email = \u0026#34;nicolas.guilloux@proton.me\u0026#34;; # Use recommended settings services.nginx.recommendedGzipSettings = lib.mkDefault true; services.nginx.recommendedOptimisation = lib.mkDefault true; services.nginx.recommendedProxySettings = lib.mkDefault true; services.nginx.recommendedTlsSettings = lib.mkDefault true; Ensuite, il nous faut dire à Nginx de rediriger le traffic entrant de blog.nicolasguilloux.eu vers le port 8080. Pour ce faire, nous allons déclarer une virtual host, lui donner quelques configurations relatives au SSL et au proxy, mais surtout lui dire de rediriger tout le traffic vers la bonne adresse. La configuration parle d’elle-même :\nservices.nginx.virtualHosts.\u0026#34;blog.nicolasguilloux.eu\u0026#34; = { forceSSL = true; enableACME = true; extraConfig = \u0026#34;proxy_buffering off\u0026#34;; locations.\u0026#34;/\u0026#34; = { proxyPass = \u0026#34;http://127.0.0.1:8080\u0026#34;; proxyWebsockets = true; extraConfig = # required when the target is also TLS server with multiple hosts \u0026#34;proxy_ssl_server_name on;\u0026#34; + # required when the server wants to use HTTP Authentication \u0026#34;proxy_pass_header Authorization;\u0026#34;; }; }; Nginx était bien mais nécessitait que le service en question expose un port pour être accessible. Comme je travaille beaucoup avec des images Docker, l’utiliser était devenu de plus en plus fastidieux car je devais réfléchir à quel port j’exposais. Si par exemple j’avais deux sites exposés sur le port 80, je devais choisir de l’exposer l’un sur le port 8080 et l’autre sur le port 8081. Bref, rapidement j’ai trouvé que l’attribution arbitraire d’un port pour éviter les conflits n’était pas pérenne dans le temps.\nCaddy Proxy Celui-ci est légèrement différent. À la base, Caddy est un serveur Web qui fournit beaucoup de fonctionnalité et se veut facile d’accès. Pour notre utilisation, c’est une image docker qui a pour principe de se servir des labels associés à un container Docker pour le router.\nRegardons comment \u0026#34;installer\u0026#34; le service the nix way :\nOn va devoir déclarer une container qui utilisera le port 80 et 443 pour respectivement le http et https.\nOn doit donner un petit nom au network Docker. Tout container appartenant à ce network sera analysé par caddy-proxy pour trouver éventuellement des labels le concernant.\nOn l’ajoute bien entendu à ce dit network.\nOn lui donne accès à notre socket Docker, pour qu’il puisse analyser les différents containers.\nOn lui donne un espace pour stocker ses données.\nUne dernière configuration doit être ajoutée pour créer le network Docker avant de lancer le container pour éviter une erreur.\nVoici donc la configuration correspondante :\nlet dockerNetwork = \u0026#34;caddy-proxy\u0026#34;; in { virtualisation.oci-containers.containers.caddy-proxy = { autoStart = true; image = \u0026#34;lucaslorentz/caddy-docker-proxy:ci-alpine\u0026#34;; ports = [ \u0026#34;80:80\u0026#34; \u0026#34;443:443\u0026#34; ]; environment = { CADDY_INGRESS_NETWORKS = \u0026#34;${dockerNetwork} }; extraOptions = [ \u0026#34;--network=${dockerNetwork} ]; volumes = [ \u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34; \u0026#34;/var/lib/caddy-proxy:/data\u0026#34; ]; }; systemd.services.docker-caddy-proxy.preStart = lib.mkAfter \u0026#39;\u0026#39; ${pkgs.docker}/bin/docker network create -d bridge ${dockerNetwork} || true \u0026#39;\u0026#39;; } Et voilà, ça fonctionne. On pourra noter une amélioration à apporter : le support de Podman. Pour l’instant, c’est hardcodé pour Docker à cause de preStart ainsi que du socket.\nSi on regarde maintenant pour instancier un service qui passerait par ce proxy, on se retrouverait avec une configuration de ce genre :\nlet dockerNetwork = \u0026#34;caddy-proxy\u0026#34;; in { virtualisation.oci-containers.containers.whoami = { autoStart = true; image = \u0026#34;jwilder/whoami\u0026#34;; extraOptions = [ \u0026#34;--network=${dockerNetwork}\u0026#34; \u0026#34;--label=caddy=whoami.example.com\u0026#34; \u0026#34;--label=caddy.reverse_proxy={{upstreams 8000}}\u0026#34; ]; }; } J’ai abandonné cette implémentation particulière d’un proxy car étant très pratique pour du développement local avec Docker, elle ne permet pas de facilement placer un service natif derrière celui-ci. De plus, je n’ai pas exploré la possibilité du SSL car je n’envisageais pas cette solution sur mon serveur.\nTraefik Ce qu’il me fallait, c’est le meilleur des deux mondes : placer des services natifs et des services dockerisés derrière un proxy. Si en plus je pouvais avoir une interface graphique pour debugger, ça serait parfait.\nTraefik m’a alors été conseillé par un ami, et rempli totalement son rôle. On peut lui dire manuellement de forward tel host sur tel adresse et port, tout comme on peut bénéficier d’une configuration avec des labels via le Docker provider.\nVoyons quelques prérequis qui expliquent la configuration :\nTraefik doit avoir accès à Docker\nOn veut son Dashboard pour pouvoir facilement débugger\nOn doit configurer au moins deux points d’entrées : un pour le http et l’autre pour le https. Le http dans cette exemple redirigera vers le https.\nOn doit configurer la génération des certificats\nOn souhaite par défaut que le dashboard soit accessible via https://traefik.local\nAvec tout ça en tête, on obtient alors la configuration par défaut suivante :\n{ config, lib, pkgs, ... }: let localCertificationDirectory = config.security.localCertification.directory; in { # Enable Traefik services.traefik.enable = true; # Let Traefik interact with Docker services.traefik.group = \u0026#34;docker\u0026#34;; services.traefik.staticConfigOptions = { api.dashboard = true; api.insecure = false; # Enable logs log.filePath = \u0026#34;/var/log/traefik/traefik.log\u0026#34;; accessLog.filePath = \u0026#34;/var/log/traefik/accessLog.log\u0026#34;; # Enable Docker provider providers.docker = { endpoint = \u0026#34;unix:///run/docker.sock\u0026#34;; watch = true; exposedByDefault = false; }; # Configure entrypoints, i.e the ports entryPoints = { websecure.address = \u0026#34;:443\u0026#34;; web = { address = \u0026#34;:80\u0026#34;; http.redirections.entryPoint = { to = \u0026#34;websecure\u0026#34;; scheme = \u0026#34;https\u0026#34;; }; }; }; # Configure certification certificatesResolvers.acme-challenge.acme = { email = \u0026#34;nicolas.guilloux@proton.me\u0026#34;; storage = \u0026#34;/var/lib/traefik/acme.json\u0026#34;; httpChallenge.entryPoint = \u0026#34;web\u0026#34;; }; }; # Dashboard services.traefik.dynamicConfigOptions.http.routers.dashboard = { rule = lib.mkDefault \u0026#34;Host(`traefik.local`)\u0026#34;; service = \u0026#34;api@internal\u0026#34;; entryPoints = [ \u0026#34;websecure\u0026#34; ]; tls = lib.mkDefault true; # Add certification # tls.certResolver = \u0026#34;acme-challenge\u0026#34;; }; # Add Dashboard to hosts networking.hosts.\u0026#34;127.0.0.1\u0026#34; = if config.services.traefik.dynamicConfigOptions.http.routers.dashboard.rule == \u0026#34;Host(`traefik.local`)\u0026#34; then [ \u0026#34;traefik.local\u0026#34; ] else [ ]; } À partir de là, on a un Traefik qui dispose d’un dashboard et qui surveille Docker, quel que soit le network.\nNote Si jamais vous voulez manipuler des headers, il faut passer par des middlewares. Regardons déjà la déclaration d’un container pour qu’il soit cabler sur Traefik. L’attribution des labels est plutôt évidentes.\nvirtualisation.oci-containers.containers.whoami = { autoStart = true; image = \u0026#34;jwilder/whoami\u0026#34;; extraOptions = [ \u0026#34;--label=traefik.enable=true\u0026#34; \u0026#34;--label=traefik.http.routers.whoami.entrypoints=websecure\u0026#34; \u0026#34;--label=traefik.http.routers.whoami.rule=Host(`whoami.example.com`)\u0026#34; \u0026#34;--label=traefik.http.routers.whoami.tls=true\u0026#34; \u0026#34;--label=traefik.http.services.whoami.loadbalancer.server.port=8000\u0026#34; # Add certification # \u0026#34;--label=traefik.http.routers.whoami.tls.certresolver=acme-challenge\u0026#34; ]; }; Pour ajouter notre fameux blog, c’est-à-dire un service natif, on peut le faire de la manière suivante :\nservices.traefik.dynamicConfigOptions.http.services.\u0026#34;blog.nicolasguilloux.eu\u0026#34; = { loadBalancer.servers = [ { url = \u0026#34;http://127.0.0.1:8080\u0026#34;; } ]; }; Traefik est pour moi la solution qui me convient le mieux, car elle réunit le meilleur des deux précédents proxy, tout en proposant davantage. Le dashboard est très pratique pour surveiller le routing, et je pourrais explorer d’autres fonctionnalités à l’avenir comme le routing TCP/UDP.\nAller plus loin Il y a plusieurs fonctionnalités que j’ai ou vais explorer avec Traefik :\nFaire de la certification en local\nFaire du routing TCP/UDP\nImplémenter du monitoring\nImplémenter + de securité (Crowdsec ?)\n","date":"2022-07-01T00:00:00Z","image":"https://nicolasguilloux.eu/articles/reverse-proxy-nixos/cover_huecfa39749c24c559ea49b0bcf938d654_423569_120x120_fill_box_smart1_3.png","permalink":"https://nicolasguilloux.eu/articles/reverse-proxy-nixos/","title":"Reverse Proxy sur NixOS"},{"content":" Matrix est un protocole de messagerie instantannée. La suite de ce ticket considère que vous connaissez les bases et notamment le glossaire. Je vous conseille fortement d’aller lire le tutoriel précédent : Matrix sur NixOS\nTelegram Messenger Le bridge Signal supporte les conversations de groupe et les messages directs. Toutefois, toute conversation chiffrée ne sera pas supportée. La petite particularité sur ce bridge est que Signal ne dispose pas d’une API. Ainsi, il va falloir utiliser une image Docker qui va simuler un accès Web à Signal.\nVoici la configuration que je préconise :\n{ config, lib, ... }: let bridgeFolder = \u0026#34;/var/lib/mautrix-signal\u0026#34;; toListIfExists = path: if (lib.pathExists path) then [ path ] else []; in { # Signal daemon virtualisation.oci-containers.containers.signald = { image = \u0026#34;docker.io/finn/signald\u0026#34;; volumes = [ \u0026#34;${bridgeFolder}/signald:/signald\u0026#34; ]; extraOptions = [ \u0026#34;--network=host\u0026#34; ]; }; # Signal bridge virtualisation.oci-containers.containers.mautrix-signal = { image = \u0026#34;dock.mau.dev/tulir/mautrix-signal\u0026#34;; extraOptions = [ \u0026#34;--network=host\u0026#34; ]; dependsOn = [ \u0026#34;signald\u0026#34; ]; volumes = [ \u0026#34;${bridgeFolder}/data:/data\u0026#34; \u0026#34;${bridgeFolder}/signald:/signald\u0026#34; ]; }; # Add configuration to Matrix server services.matrix-synapse.app_service_config_files = toListIfExists \u0026#34;${bridgeFolder}/data/registration.yaml\u0026#34;; } Si on résume, toutes les données sont stockées dans /var/lib/mautrix-signal. On ajoute les image Docker qui permet de lancer le bridge.\nL’image signald est le daemon pour pouvoir simuler une interface Web auprès de notre application Signal. C’est nécessaire pour pouvoir récupérer les messages en toute sécurité vu que Signal ne dispose pas d’API. C’est aussi pour celà qu’on doit partager le volume où sont stockées toutes les informations (comme les avatars) entre le daemon et le bridge.\nOn va dès maintenant configurer ce dernier en éditant en tant que root le fichier /var/lib/mautrix-signal/data/config.yaml…​ Enfin faite votre nixos-rebuild switch pour lancer le bridge.\nOn va changer différentes clés dans le fichier, je vais lister ce les clés qui ont changé :\nhomeserver: address: http://localhost:8008 domain: server_name verify_ssl: false signal: socket_path: /signald/signald.sock outgoing_attachment_dir: /signald/attachments avatar_dir: /signald/avatars data_dir: /signald/data bridge: permissions: \u0026#34;*\u0026#34;: user \u0026#34;@pseudo:server_name\u0026#34;: admin homeserver.address : Votre serveur Matrix, pas besoin de passer par internet, il est disponible en local\nhomeserver.domain : C’est le server_name, vous devez maintenance savoir ce que c’est :)\nhomeserver.verify_ssl : Comme on est dans une boucle locale, par besoin de vérifier le SSL\nsignal.socket-path : Socket pour dialoguer avec le daemon\nsignal.outgoing_attachment_dir : Répertoire du daemon où sont mis les pièces jointes\nsignal.avatar_dir : Répertoire du daemon où sont mis les avatars\nsignal.data_dir : Répertoire du daemon où sont mis les autres données utiles aux bridges\nbridge.permissions : Ce sont les permissions. Pour ma part, j’ai mis \u0026#34;*\u0026#34;: user pour que tous les utilisateurs puissent utiliser le bridge, et enfin \u0026#34;@pseudo:server_name\u0026#34;: admin pour que votre utilisateur puisse l’administrer\nUne fois ça fait, pensez à redémarrer votre image docker docker restart mautrix-signal et faites ensuite un petit nixos-rebuild switch. Normalement, matrix-synapse se redémarrera car le fichier registration.yaml existera.\nVous pouvez maintenant constater que vous pouvez parler au bot dans votre client Matrix en ouvrant une conversation avec @signalbot:server_name. Celui-ci devrait accepter votre invitation. Vous pouvez alors lui demander de l’aide comme il le propose.\nA partir d’ici vous avez plusieurs choix, car vous pouvez :\nCréer un compte de zéro en utilisant la commande register +33xxxxxxxxx. Si vous n’avez pas signal sur votre téléphone, cela permettra de tout recevoir sur Matrix directement.\nLier votre compte déjà existant, relié à votre téléphone, et forward tous les messages à Matrix en tapant link et en scannant le QR Code.\nUne fois connecté, attendez un peu et vous allez recevoir plein d’invitations :) Bien joué, tout devrait fonctionner !\n","date":"2021-04-08T00:00:00Z","image":"https://nicolasguilloux.eu/articles/mautrix-signal/cover.svg","permalink":"https://nicolasguilloux.eu/articles/mautrix-signal/","title":"Le Bridge Signal pour Matrix"},{"content":" Matrix est un protocole de messagerie instantannée. La suite de ce ticket considère que vous connaissez les bases et notamment le glossaire. Je vous conseille fortement d’aller lire le tutoriel précédent : Matrix sur NixOS\nTelegram Messenger Le bridge de Telegram supporte quasiment toutes les fonctionnalités. La configuration est quasiment la même que pour Mautrix Facebook hormis un léger changement au niveau de la configuration d’une API. Je n’ai volontairement pas suivi la configuration proposé par NixOS car je n’ai jamais réussi à la faire fonctionner, et je souhaite avoir une installation cohérente. Comme NixOS ne propose pas de module pour Mautrix Facebook, Mautrix Telegram et Mautrix Signal, je préfère les configurer de la même manière.\nVoici la configuration que je préconise :\n{ config, lib, ... }: let bridgeFolder = \u0026#34;/var/lib/mautrix-telegram\u0026#34;; toListIfExists = path: if (lib.pathExists path) then [ path ] else []; in { # Telegram bridge virtualisation.oci-containers.containers.mautrix-telegram = { image = \u0026#34;dock.mau.dev/tulir/mautrix-telegram\u0026#34;; extraOptions = [ \u0026#34;--network=host\u0026#34; ]; volumes = [ \u0026#34;${bridgeFolder}/data:/data\u0026#34; ]; }; # Add configuration to Matrix server services.matrix-synapse.app_service_config_files = toListIfExists \u0026#34;${bridgeFolder}/data/registration.yaml\u0026#34;; } Si on résume, toutes les données sont stockées dans /var/lib/mautrix-telegram. On ajoute l’image docker qui permet de lancer le bridge.\nOn va dès maintenant le configurer en éditant en tant que root le fichier /var/lib/mautrix-telegram/data/config.yaml…​ Enfin faite votre nixos-rebuild switch pour lancer le bridge.\nDans un premier temps, il faut faire une application sur le site de Telegram pour récupérer un ID et un hash qui serviront au bridge pour interagir avec l’API. Pour ce faire, allez sur cette page d’aide de Telegram et suivez les instructions pour récupérer le api_id et le api_hash.\nOn va changer différentes clés dans le fichier, je vais lister ce les clés qui ont changé :\nhomeserver: address: http://localhost:8008 domain: server_name verify_ssl: false telegram: api_id: #ApiId# api_hash: #ApiHash# bridge: permissions: \u0026#34;*\u0026#34;: user \u0026#34;@pseudo:server_name\u0026#34;: admin homeserver.address : Votre serveur Matrix, pas besoin de passer par internet, il est disponible en local\nhomeserver.domain : C’est le server_name, vous devez maintenance savoir ce que c’est :)\nhomeserver.verify_ssl : Comme on est dans une boucle locale, par besoin de vérifier le SSL\ntelegram.api_id : ID fourni par Telegram sur le site\ntelegram.api_hash : Hash fourni par Telegram sur le site\nbridge.permissions : Ce sont les permissions. Pour ma part, j’ai mis \u0026#34;*\u0026#34;: user pour que tous les utilisateurs puissent utiliser le bridge, et enfin \u0026#34;@pseudo:server_name\u0026#34;: admin pour que votre utilisateur puisse l’administrer\nUne fois ça fait, pensez à redémarrer votre image docker docker restart mautrix-telegram et faites ensuite un petit nixos-rebuild switch. Normalement, matrix-synapse se redémarrera car le fichier registration.yaml existera.\nVous pouvez maintenant constater que vous pouvez parler au bot dans votre client Matrix en ouvrant une conversation avec @telegrambot:server_name. Celui-ci devrait accepter votre invitation. Vous pouvez alors lui demander de l’aide comme il le propose. Pour lier votre compte, faites !tg login et suivez les instructions.\nUne fois connecté, attendez un peu et vous allez recevoir plein d’invitations :) Bien joué, tout devrait fonctionner !\n","date":"2021-04-05T00:00:00Z","image":"https://nicolasguilloux.eu/articles/mautrix-telegram/cover.svg","permalink":"https://nicolasguilloux.eu/articles/mautrix-telegram/","title":"Le Bridge Telegram pour Matrix"},{"content":" Matrix est un protocole de messagerie instantannée. La suite de ce ticket considère que vous connaissez les bases et notamment le glossaire. Je vous conseille fortement d’aller lire le tutoriel précédent : Matrix sur NixOS\nFacebook Messenger Bon, qu’on se le dise, j’aimerai bien partir de Facebook mais beaucoup de personnes ne veulent pas par simplicité. Même si ça m’embête pour des raisons évidentes, je dois rester dessus car j’ai vraiment des personnes que j’aime beaucoup qui refusent de passer sur d’autres plateformes. C’est d’ailleurs un intérêt de ce bridge : je vais désinstaller toutes les applications Facebook, ma seule interaction sera via Matrix.\nDans un premier temps, on va préparer notre base de données afin d’y stocker les données utilent au bridge. Pour le moment, celui-ci ne supporte que PostgreSQL. Ca tombe bien, on a déjà une BDD disponible via le serveur Synapse. Aussi, on va pouvoir facilement créer un user et une base.\nsudo -u postgres psql CREATE ROLE \u0026#34;mautrixfacebook\u0026#34; WITH LOGIN PASSWORD \u0026#39;VotreMotDePasseUnique\u0026#39;; CREATE DATABASE \u0026#34;mautrixfacebook\u0026#34; WITH OWNER \u0026#34;mautrixfacebook\u0026#34; TEMPLATE template0 LC_COLLATE = \u0026#34;C\u0026#34; LC_CTYPE = \u0026#34;C\u0026#34;; \\q Une fois fait, on va pouvoir préparer notre module qui va démarrer l’image docker du bridge. On va aussi câbler ce bridge à notre instance Matrix.\n{ config, lib, ... }: let bridgeFolder = \u0026#34;/var/lib/mautrix-facebook\u0026#34;; toListIfExists = path: if (lib.pathExists path) then [ path ] else []; in { # Facebook bridge virtualisation.oci-containers.containers.mautrix-facebook = { image = \u0026#34;dock.mau.dev/tulir/mautrix-facebook\u0026#34;; extraOptions = [ \u0026#34;--network=host\u0026#34; ]; volumes = [ \u0026#34;${bridgeFolder}/data:/data\u0026#34; ]; }; # Add configuration to Matrix server services.matrix-synapse.app_service_config_files = toListIfExists \u0026#34;${bridgeFolder}/data/registration.yaml\u0026#34;; } Si on résume, toutes les données sont stockées dans /var/lib/mautrix-facebook. On ajoute l’image docker qui permet de lancer le bridge. La partie où on relie notre bridge à notre serveur est commentée pour le moment car le fichier en question sera généré par le bridge, et donc n’existe pas avant d’avoir bien parametré le bridge.\nOn va dès maintenant le configurer en éditant en tant que root le fichier /var/lib/mautrix-facebook/data/config.yaml…​ Enfin faite votre nixos-rebuild switch pour lancer le bridge.\nOn va changer différentes clés dans le fichier, je vais lister ce les clés qui ont changé :\nhomeserver: address: http://localhost:8008 domain: server_name verify_ssl: false appservice: database: postgres://mautrixfacebook:VotreMotDePasseUnique@127.0.0.1/mautrixfacebook bridge: permissions: \u0026#34;*\u0026#34;: user \u0026#34;@pseudo:server_name\u0026#34;: admin homeserver.address : Votre serveur Matrix, pas besoin de passer par internet, il est disponible en local\nhomeserver.domain : C’est le server_name, vous devez maintenance savoir ce que c’est :)\nhomeserver.verify_ssl : Comme on est dans une boucle locale, par besoin de vérifier le SSL\nappservice.database : Lien vers *votre base de données. Pensez à changer le mot de passe pour celui que vous avez utilisé au dessus.\nbridge.permissions : Ce sont les permissions. Pour ma part, j’ai mis \u0026#34;*\u0026#34;: user pour que tous les utilisateurs puissent utiliser le bridge, et enfin \u0026#34;@pseudo:server_name\u0026#34;: admin pour que votre utilisateur puisse l’administrer\nUne fois ça fait, pensez à redémarrer votre image docker docker restart mautrix-facebook et faites ensuite un petit nixos-rebuild switch. Normalement, matrix-synapse se redémarrera car le fichier registration.yaml existera.\nVous pouvez maintenant constater que vous pouvez parler au bot dans votre client Matrix en ouvrant une conversation avec @facebookbot:server_name. Celui-ci devrait accepter votre invitation. Vous pouvez alors lui demander de l’aide comme il le propose. Pour lier votre compte, faites login \u0026lt;email\u0026gt; avec l’email de votre compte Facebook bien entendu ! Suivez ce qu’il vous dit, il va vous demander votre mot de passe et potentiellement votre code de double authentification.\nUne fois connecté, attendez un peu et vous allez recevoir plein d’invitations :) Bien joué, tout devrait fonctionner !\n","date":"2021-03-29T00:00:00Z","image":"https://nicolasguilloux.eu/articles/mautrix-facebook/cover.svg","permalink":"https://nicolasguilloux.eu/articles/mautrix-facebook/","title":"Le Bridge Facebook pour Matrix"},{"content":" Comme beaucoup de personnes, j’ai beaucoup de messageries qui ont su évoluer (ou pas) dans le temps. Et chacunes de ces messageries apportent ses avantages et ses inconvénients, et la plupart des gens ne veulent pas toutes les avoir. Et j’en fais partie !\nAussi, j’ai toujours reluqué Matrix de loin. Les seules fois où j’avais abordé ce standard, j’ai été très déçu à cause de la lenteur de celui-ci et aussi le fait que ce soit extrêmement intimidant au niveau sécurité.\nFinalement, j’ai décidé de me lancer en entendant parler de Beeper qui permettait de centraliser plein de protocoles au même endroit. J’ai été déçu de voir que c’était très payant pour une utilisation domestique. Et j’ai remarqué par mon don incroyable de lecture de la seule et unique page disponible que Beeper était une application basée sur Matrix et la notion de bridges. Donc, en théorie, on peut faire la même chose sans payer.\nQu’est-ce que Matrix Matrix est un standard OpenSource pour construire une messagerie sécurisée en temps réel et décentralisée. Beaucoup de buzz words, on va expliquer tout ça.\nC’est un standard, ce qui veut dire que Matrix n’est pas un logiciel mais simplement une liste de fonctionnalités à implémenter afin de supporter le protocole. C’est un peu comme si on parlait d’un mixeur, qui est la fonctionnalité, ce qui ne l’empêche pas d’avoir un nom donné par la marque ou par les utilisateurs. Le mixeur de mes parents s’appelle Bob. Une messagerie sécurisée en temps réel, c’est assez simple à comprendre. Pour le côté décentralisé, ça veut dire que un seul et unique serveur n’est pas souverain du réseau. Ainsi, installer un serveur chez vous permettra d’avoir accès au service sur votre réseau. Matrix implémente aussi un système pour faire dialoguer les serveurs entre eux, comme ça votre serveur ne reste pas dans son coin et pourra dialoguer avec le monde extérieur.\nOn a parlé plus haut des bridges, et ça c’est une des fonctionnalités de Matrix. Le principe est qu’on peut ajouter un genre de plugin qui joue le rôle d’interface avec quelque chose d’autre. Ouais c’est un peu abstrait, mais concrètement un bridge peut se charger en temps réel de relayer les messages d’une autre messagerie par exemple.\nInstallation du serveur J’ai rassemblé tous mes efforts pour que tout fonctionne dans un dossier de mon installation NixOS. Il peut varier dans le temps, j’actualiserais le tutoriel et les liens vers ma configuration en fonction des updates.\nLe serveur Synapse Tout commence d’abord par installer Synapse qui est un serveur Matrix. Matrix étant un standard, Synapse est une implémentation de celui-ci. Si vous êtes déjà perdu, relisez le point précédent ;)\nIci, NixOS nous a bien facilité la tache vu qu’une configuration est disponible, donc on peut aller très vite.\nservices.matrix-synapse = { enable = true; server_name = \u0026#34;matrix.nicolasguilloux.eu\u0026#34;; registration_shared_secret = \u0026#34;UnSecretTemporaire\u0026#34;; # enable_registration = true; listeners = [ { port = 8008; bind_address = \u0026#34;::1\u0026#34;; type = \u0026#34;http\u0026#34;; tls = false; x_forwarded = true; resources = [ { names = [ \u0026#34;client\u0026#34; \u0026#34;federation\u0026#34; ]; compress = false; } ]; } ]; }; # For the registration of a user services.matrix-synapse.registration_shared_secret = \u0026#34;UnSecretTemporaire\u0026#34;; environment.systemPackages = [ pkgs.matrix-synapse ]; Il faut s’assurer que l’option server_name correspond bien à l’adresse finale du serveur. C’est important pour faire dialoguer le monde extérieur avec notre instance. Si jamais vous vous lancez dans l’installation et que cette adresse est fausse, il faudra tout recommencer.\nIci, on n’utilise qu’un seul port : le 8008. C’est celui conseillé dans la documentation. Vous remarquerez qu’il n’y a pas de SSL, c’est parce que mon serveur sera exposé à travers un Reverse Proxy géré par Nginx. On va voir ça après.\nL’option registration_shared_secret est là uniquement pour enregistrer votre utilisateur administrateur. Il faudra bien penser à l’enlever, car elle permet de créer des utilisateurs un peu comme on veut en utilisant le dit mot de passe.\nEt enfin, pas besoin d’importer le paquet de Synapse dans les ceux de système hormis pour l’inscription d’un nouvel utilisateur via un terminal.\nLa base de données Il faudra aussi configurer une base de données PostgreSQL pour le serveur.\n# Manually configure PostgreSQL # ref: https://www.foxypossibilities.com/2018/02/04/running-matrix-synapse-on-nixos/ services.postgresql.enable = true; services.postgresql.initialScript = pkgs.writeText \u0026#34;synapse-init.sql\u0026#34; \u0026#39;\u0026#39; CREATE ROLE \u0026#34;matrix-synapse\u0026#34; WITH LOGIN PASSWORD \u0026#39;${config.secrets.matrix.database}\u0026#39;; CREATE DATABASE \u0026#34;matrix-synapse\u0026#34; WITH OWNER \u0026#34;matrix-synapse\u0026#34; TEMPLATE template0 LC_COLLATE = \u0026#34;C\u0026#34; LC_CTYPE = \u0026#34;C\u0026#34;; \u0026#39;\u0026#39;; Ici, mon mot de passe est défini bien au chaud dans la config. Pensez à mettre votre mot de passe. Vous pouvez aussi faire cette étape à la mano en allant tater sudo -u postgres psql.\nCréation de notre admin Avant d’exposer sur Internet, on va déjà créer notre utilisateur admin puis désactiver la possibilité de s’enregistrer en utilisant les lignes de commandes. Comme ça, on ferme une porte !\nIci, rappelez vous la registration_shared_secret mis plus haut et simplement tapez la commande suivante\nregister_new_matrix_user --shared-secret \u0026#34;UnSecretTemporaire\u0026#34; http://localhost:8008\nOn suit donc tout ce qu’il nous dit comme il faut en prenant soin de mettre votre utilisateur Admin.\nLe Reverse Proxy On va maintenant configurer notre Reverse Proxy pour qu’il puisse être accessible du monde extérieur. C’est important aussi pour pouvoir dialoguer avec les autres serveurs.\nlet listenPort = port: ssl: { addr = \u0026#34;0.0.0.0\u0026#34;; port = port; ssl = ssl; }; in { # Open port networking.firewall.allowedTCPPorts = [ 8448 ]; # Reverse proxy services.nginx.virtualHosts.\u0026#34;matrix.nicolasguilloux.eu\u0026#34; = { enableACME = true; forceSSL = true; listen = [ (listenPort 80 false) (listenPort 443 true) (listenPort 8448 true) ]; locations.\u0026#34;/_matrix\u0026#34; = { proxyPass = \u0026#34;http://[::1]:8008\u0026#34;; }; }; } Ici, on voit que nous redirigeons tout vers notre serveur Synpase. On peut aussi voir qu’on utilise le port 8448. Il est important car c’est ce port qui est utilisé par la fédération des serveurs Matrix. Ainsi, un serveur lambda ira questionner notre serveur via ce port uniquement.\nUne fois tout installé, vous pouvez d’ailleurs tester votre serveur pour voir s’il est bien accessible par la fédération.\nSi vous avez tout bien fait, normalement vous devez pouvoir vous connecter sur Element.io, modifier le serveur d’accueil (le fameux server_name) et vous connecter. Vous remarquerez alors que votre pseudo est pseudo:server_name. Par exemple, pour ma part, c’est nover:matrix.nicolasguilloux.eu.\nLes Bridges Une fois votre serveur fonctionnel, vous pouvez jouir de toutes les fonctionnalités de Matrix de base. Vous pouvez donc rejoindre des salons et discuter avec des personnes mêmes si elles ne sont pas sur votre serveur grâce à la magie de la fédération.\nOn va maintenant pouvoir ajouter des bridges qui vont être les interfaces entre un autre protocole et celui de Matrix. En plus simple : ça va permettre d’envoyer des messages en utilisant Matrix vers des destinataires comme Signal ou encore Messenger.\nIci, je ne vais passer en revue que les bridges que j’ai implémenté sur mon serveur. On notera que la plupart ont été conçu par la même personne et donc ont le préfix mautrix. On peut donc constater qu’ils se configurent quasiment de la même manière. Je vais aussi essayer de trier l’ordre des bridges ci-dessous en fonction de leur difficulté à installer. Ca permettra de monter progressivement en difficulté.\n","date":"2021-03-26T00:00:00Z","image":"https://nicolasguilloux.eu/articles/matrix/matrix.svg","permalink":"https://nicolasguilloux.eu/articles/matrix/","title":"Matrix sur NixOS"},{"content":" J’ai décidé de revoir mon miroir intelligent pour plusieurs raisons :\nJ’ai domotisé ma maison, et avoir un affichage des différents capteurs serait vraiment un plus\nLa page web affichée était fait à la main, alors que des solutions bien plus jolies existent comme MagicMirror\nLe miroir était beaucoup trop épais, il sortait du mur d’une 10aine de centimètres\nIl était moche\nIl était beaucoup trop lourd, impossible de l’installer sur un mur sans mettre 1 ou 2 chevilles\nL’écran mettait trop de temps à s’allumer, c’est dommage pour quelque chose qui doit donner des informations de manière spontanée de prendre 10 secondes les afficher\nAutre chose qui en découle, mais on pouvait laisser l’écran allumer, mais il consommait beaucoup trop\nPour toutes ces raisons, j’ai décidé de le démonter pour en faire une nouvelle version.\nMatériel Ecran Je ne garderais par l’écran car c’est la principale raison pour laquelle le miroir n’était pas satisfaisant. Comme c’est une ancienne télévision, tout était prévu pour avoir de l’espace derrière l’écran et que celle-ci soit posée sur un meuble. On peut le voir notamment avec les ports HDMI qui sont à la perpendiculaire de la dalle, son épaisseur et son poids.\nJ’ai réussi à récupérer un écran LCD d’un ordinateur portable et j’ai commandé une carte d’aquisition pour le modèle de l’écran de ~13€ qui fera l’interface entre la sortie HDMI du Rapsberry Pi et la dalle LCD. Le principal intérêt de récupérer un écran comme celui-ci est qu’il a été prévu pour ne pas consommer car étant à l’origine dans un appareil mobile, que son poids et son épaisseur est vraiment faible et que cela permet de déporter la dite carte où on peut pour économiser encore une fois de l’espace et réduire l’épaisseur du miroir.\nL’autre intérêt est le temps pour s’allumer. Il est quasi immédiat, c’est ainsi que sont utilisés les écrans d’ordinateurs portables. Vous verrez rarement un ordinateur mettre 10 secondes à s’allumer lorsque vous le sortez de veille, ou alors c’est votre OS qui prend son temps et non l’écran.\nEt enfin la sécurité : je suis toujours plus à l’aise quand je ne travaille pas avec des tensions mortelles. Aussi, l’écran LCD et sa carte sont alimentés en 12V, ce qui permettra de sortir l’alimentation hors du miroir. Il faudra néanmoins prévoir un abaisseur de tension pour alimenter le Raspberry Pi en 5V.\nRaspberry Pi Parlons du Raspberry Pi. Il s’avère que je pensais avoir un Raspberry Pi 2, mais en fait c’est le premier modèle. Il est donc extrêmement lent, il n’a clairement pas les reins pour produire un affichage rapide qui pourrait avoir des animations fluides. Aussi, il faudra que je change ce composant, il n’est pas approprié. Pour le moment, j’ai rien d’autre sous la main, et donc je l’utilise comme navigateur avec MagicMirror hébergé à un autre endroit. Dans la suite, je ferais comme si MagicMirror était hébergé sur le Raspberry Pi\nLe Raspberry Pi va héberger le logiciel qui va nous permettre de facilement intégrer différents modules pour avoir l’affichage le plus complet possible : MagicMirror. C’est un logiciel spécialement conçu ce qu’on veut faire. Vous pouvez rajouter des plugins pour avoir toute sorte d’information sur l’écran. Comme tout côté logiciel a été fait, on ne va pas beaucoup aborder la configuration de MagicMirror hormis le fait d’avoir une installation fonctionnelle.\n","date":"2021-03-10T00:00:00Z","image":"https://nicolasguilloux.eu/articles/mirint-v2/screen_huf9b2fdd55abb6aac5426b60d01d0381a_176971_120x120_fill_q75_box_smart1.jpg","permalink":"https://nicolasguilloux.eu/articles/mirint-v2/","title":"Mirint V2"},{"content":" Lola est une extension firefox qui permet de styliser votre nouvel onglet. C’est ma première approche vers les extensions des navigateurs.\nElle est fortement inspirée de l’extension \u0026#34;Momentum\u0026#34; mais ajoute des fonctionnalités qui me plaisent : * La météo * Les raccourcis en bas à gauche sous forme d’icones * Des notifications en bas à droite\nExtension Firefox - Github\n","date":"2018-03-18T00:00:00Z","image":"https://nicolasguilloux.eu/articles/lola/screenshot_hu94c0f27793af0e5688192aac3ce5c898_237487_120x120_fill_q75_box_smart1.jpg","permalink":"https://nicolasguilloux.eu/articles/lola/","title":"Lola"},{"content":" Le miroir intelligent est une petite interface qui devrait, le matin et le soir (ou à vrai dire, à chaque fois que vous allez dans la salle de bain), vous donner des informations pertinentes.\nLe but est de se dispenser de vérifier son Smartphone en affichant les choses à faire dans la journée, la météo et quelques news. Et dans un soucis d’ergonomie, pas besoin d’un bouton pour l’activer : un capteur de proximité se chargera de le réveiller quand vous le regardez.\nPour l’instant, le projet n’en est qu’à un stade de prototype non fini. Il n’est toutefois pas abandonné. Après l’achèvement des premières fonctionnalités, le travail suivant sera d’implémenter une reconnaissance vocale.\nMatériel Mirint regroupe différents appareils \u0026#34;recyclés\u0026#34; : ils ne servaient plus, donc je me suis servi.\nEcran de télévision LCD\nRaspberry Pi 2 et son alimentation\nCâble HDMI\nUn coffret\nUn film miroir sans teint\nUne plaque de plexiglas\nDu fil et de quoi souder\nLa première étape a été de dépioter le téléviseur. Afin que le miroir soit le plus fin possible, il faut enlever toute la partie protection plastique pour ne garder que la dalle et les circuits du téléviseur qui se divisent souvent en deux parties : un circuit d’alimentation où on relit l’appareil au secteur et un circuit d’entrées/sorties où vous branchez HDMI etc.\nIl est important de ne pas toucher le circuit d’alimentation quand le système est sous tension ! Il y a risque d’électrisation voire électrocution !\nLe Raspberry Pi est relié donc en HDMI au téléviseur. On pourrait auto-alimenter le RPi grâce au port USB du téléviseur, mais il sera tributaire de sa puissance. De plus, si le téléviseur est éteint, il y a de grandes chances que sur la plus part des téléviseur, le port USB soit désactivé. On opte donc pour une alimentation séparée.\nLe coffret a été raboté afin de pouvoir placer le téléviseur sur ses rebords et donc avoir la dalle sur le même plan horizontal que les bords du coffret. Il faudra aussi faire en sorte que ces mêmes bords ainsi que ceux du téléviseur soient noirs (peinture ou scotch noir).\nLa plaque de plexiglas a été découpée avec les dimensions extérieures du coffret afin qu’elle couvre toute la surface.\nLe film miroir a été collé sur la surface qui sera vers l’intérieur du coffret afin d’éviter toute dégradation et rentrée de lumière. Pour le mettre en place :\nBien laver le plexiglas,\nMettre de l’eau savoneuse sur la surface à coller,\nEnlever le film protecteur du revêtement miroir,\nPlacer le film progressivement sur la surface en raclant avec une carte afin de chasser les bulles d’air\nUne fois placé et bien seché, couper l’excédent de film\nPour ma part, j’ai percé puis fraisé le plexiglas pour le visser sur le coffret.\nPar ailleurs, on veut pouvoir allumer le téléviseur sans appuyer physiquement sur le bouton \u0026#34;Allumer\u0026#34; car ça contraint à démonter le miroir à chaque fois. Ainsi, on regarde la tension appliquée aux bornes de ce bouton poussoir. Généralement, il y a 4 pattes donc pour peut vérifier avec deux bornes en diagonale.\nUne fois trouvé (pour ma part 3,3V), on soude deux fils : un qui ira à la masse du Raspberry Pi et l’autre à un de ses nombreux GPIO, j’ai choisi le n°7. Pour voir la partie logicielle, rendez vous un peu plus bas au paragraphe \u0026#34;Contrôle du téléviseur\u0026#34;.\nLogiciel La partie logicielle est obsolète, puisque maintenant il y a MagicMirror qui propose de faire tout ce que j’ai pu proposer.\nDans un premier temps, veillez à bien configurer votre téléviseur pour s’allumer lorsque qu’on le branche et de choisir la source HDMI par défaut. Vous pouvez aussi configurer la profondeur du noir : plus il sera profond plus le rendu sera de qualité.\nDe plus, vous pouvez configurer le téléviseur pour ne pas s’éteindre. Une amélioration sera à prévoir pour économiser de l’énergie.\nVenons au Raspberry qui sera le cerveau de notre miroir. J’ai choisi de faire l’affichage en HTML sur un serveur Web qui sera pour ma part plus facile à maintenir. Toutefois, avant parler du coeur du projet, il faut configurer notre Raspberry. Je me suis basé sur l’OS Raspbian Jessie Lite. Je pars du principe que les périphériques branchés fonctionnent correctement (comme la carte WiFi de votre RPi).\nConnexion au Wifi Commençons par chercher le SSID de votre réseau (son petit nom en fait) en scannant ce que le RPi reçoit : sudo iwlist wlan0 scan. Cherchez le SSID de votre réseau et notez le dans un coin de votre tête.\nOn va maintenant modifier les paramètres des réseaux WiFi sudo nano /etc/wpa_supplicant/wpa_supplicant.conf puis rentrez les informations comme suit à la fin du fichier (ou dans le champ correspondant s’il existe déjà la variable) :\nnetwork={ ssid=\u0026#34;votre SSID\u0026#34; psk=\u0026#34;votre mot de passe\u0026#34; } ATTENTION : Votre mot de passe est stocké en clair.\nEnsuite, on valide nos changements en effectuant ce petit bout de code : sudo wpa_cli reconfigure\nOn aura besoin d’une interface graphique et de mettre à jour le bousin. On installe donc un serveur X et on met à jour le système (et un petit brin de ménage au cas ou) avec la ligne suivante :\nsudo apt-get update sudo apt-get --no-install-recommends install xserver-xorg xserver-xorg-video-fbdev xinit pciutils xinput xfonts-100dpi xfonts-75dpi xfonts-scalable x11-xserver-utils unclutter sudo apt-get dist-upgrade sudo apt-get autoremove Paramétrage du Raspberry Pi On va maintenant aller dans les configurations de base du RPi : sudo raspi-config. Cela vous amènera sur l’interface \u0026#34;graphique\u0026#34; suivante :\n]\nOn configure comme ça nous plait en changeant le mot de passe et les options de localisation. On choisit ensuite le menu Interfacing Option pour activer le SSH afin de piloter le miroir à distance.\nEnfin, on appuie 2 fois sur Tab pour sélectionner \u0026#34;Finish\u0026#34; et on accepte de redémarrer notre Raspberry Pi.\nRotation de l’écran Une rotation de l’écran peut être souhaitable suivant le sens de votre miroir. Il nous faut alors modifier un fichier en suivant cette commande : sudo nano /boot/config.txt et on y ajoute la ligne display_rotate = 1\nVoici les différentes options :\n0 : Orientation normale\n1 : 90 degrés\n2 : 180 degrés\n3 : 270 degrés\nConfiguration de l’interface graphique D’abord, on ajoute un nouvel utilisateur pour se connecter avec lors des connexions SSH. On lance la commande sudo adduser NouvelUtilisateur. On répond gentillement à tout ce qu’il nous demande.\nOn souhaite maintenant charger juste un navigateur. Il faut donc choisir votre navigateur préféré, j’ai choisi Chromium. Pour l’installer : sudo apt-get install chromium-browser\nEnsuite, pour lancer le navigateur en plein écran sur GitHub, il faut suivre la commande suivante :\nstartx /usr/bin/chromium-browser https://github.com/ --window-size=1080,1920 --start-fullscreen --kiosk --incognito -- -nocursor Il faut prendre garde à l’orientation de l’écran et sa résolution. Pour ma part, je l’avais mis format portrait en full HD.\nPour l’ajouter au démarrage, édite un fichier par la commande nano ~/.bashrc sous l’utilisateur \u0026#34;pi\u0026#34; et ajoute la commande.\nIl faudra maintenant arrêter l’écran de veille en éditant le fichier lightdm.conf par la commande suivant sudo nano /etc/lightdm/lightdm.conf et on ajoute xserver-command=X -s 0 dpms.\nPilotage à distance Notre miroir n’a ni clavier, ni souris. Et rien n’est moins pratique que de contrôler le miroir par la pensée. On va donc se servir du protocole VNC qui va nous servir à piloter l’interface graphique à distance, comme avec le SSH (ils peuvent d’ailleurs être liés). Pour cela, on installe x11vnc : sudo apt-get install x11vnc. Ensuite, on peut lancer 1 session avec x11vnc -auth guess une fois startx lancé par SSH.\nContrôle du téléviseur Cela découle directement du soudage du bouton. Dans un premier, on installe WiringPi en suivant les instructions de ce lien. Cela nous permettra d’utiliser facilement les GPIO ! Pour plus d’informations, je vous laisse checker le blog d’Idleman.\nUne fois installé, on peut commencer les festivités. On paramètre d’abord le GPIO pour être en mode \u0026#34;out\u0026#34; : gpio mode 7 out. Comme je l’ai dis précedemment, j’ai choisi le GPIO 7 (en suivant le schéma joint). On peut ensuite piloter le port en utilisant gpio write 7 bit en remplaçant \u0026#34;bit\u0026#34; par 1 pour du 3,3V ou 0 pour du 0V.\nOn peut voir que le bouton réagit par front descendant en s’amusant à changer ces valeurs (donc pour simuler le bouton appuyé, on place le GPIO à 0).\nAinsi, pour simuler l’appui du bouton, on utilise la ligne suivante :\ngpio write 7 0 \u0026amp;\u0026amp; sleep 1 \u0026amp;\u0026amp; gpio write 7 1 Pour paramétrer le GPIO en mode out et à l’état 1 (repos du bouton), il nous faut éditer le fichier /home/pi/.bashrc et rajouter les lignes suivantes :\ngpio mode 7 out gpio write 7 1 Ainsi à chaque démarrage, on configure le GPIO 7 en mode Out et à l’état 1.\n","date":"2017-07-10T00:00:00Z","image":"https://nicolasguilloux.eu/articles/mirint-v1/cover_hu98ba8fe3a3318e23b8dc99810e3a1255_71397_120x120_fill_q75_box_smart1.jpg","permalink":"https://nicolasguilloux.eu/articles/mirint-v1/","title":"Mirint"},{"content":" La Cafetière à Induction Domotisée, aka CID, est une cafetière avec plus d’un atout dans sa poche.\nLe but de ce projet était de faire du café rapidement, silencieusement avec la même qualité que les cafetières à dosette. En bref, combler les lacunes de ces dernières en ajoutant une partie domotique.\nLe projet a été commencé par mes soins, puis poursuivi dans le cadre des projets de deuxième année de l’ENSEA avec Valentin Loire. Nous poursuivons jusqu’à ce jour le développement.\nVoir sa page de présentation\n","date":"2017-06-25T00:00:00Z","image":"https://nicolasguilloux.eu/articles/cid/photo_huf45cc4d72853f449b868d64e82ad54c3_203231_120x120_fill_q75_box_smart1.jpg","permalink":"https://nicolasguilloux.eu/articles/cid/","title":"Cafetière à Induction Domotisée"},{"content":"Douglas est une enceinte Bluetooth Low-Cost. Une batterie pour portable recyclée, à peu près 15€ de l\u0026rsquo;huile de coude et vous voilà avec un objet essentiel pour toute sortie entre amis. Pourquoi l\u0026rsquo;ourson ? Parce que c\u0026rsquo;est mignon, ça protège bien le matériel qu\u0026rsquo;il y a dedans et que c\u0026rsquo;est original.\nDouglas est fonctionnel, mais toujours en développement. En effet, je souhaite y apporter quelques fonctionnalités comme la visualisation de la charge de la batterie, le réveil de l\u0026rsquo;enceinte sans besoin de bouton physique (hormis pour l\u0026rsquo;appairage).\nVersion 1 Douglas a surtout pour principe de ne pas couter cher en achetant le minimum possible. Ainsi, seuls les objets ayant un lien dans la liste suivante ont été acheté, le reste étant de la récupération.\nUne batterie Li-Ion Un amplificateur symétrique Deux haut-parleurs 3W Un circuit de charge pour batterie Li-Ion Un module Bluetooth A2DP (le BK800L) Des résistances de 10kΩ, de des boutons poussoirs Des fils, de l\u0026rsquo;étain et un fer à souder Une plaquette pour souder On en a en tout pour une 15aine d\u0026rsquo;euros, on s\u0026rsquo;en sort donc pas trop mal. Il reste maintenant à souder tous les composants ensembles afin que tout fonctionne correctement.\nLes choses sérieuses arrivent et il faudra être bien concentré pour la suite des évènements. En effet, le module Bluetooth est un enfer à souder pour peu qu\u0026rsquo;on n\u0026rsquo;ai ni fil à wrapper, ni un fer à souder digne de ce nom\u0026hellip; J\u0026rsquo;ai donc fait au possible. J\u0026rsquo;ai dénudé un fil multibrin pour découper des brins de longueur 3cm. J\u0026rsquo;ai ensuite soudé chaque brin sur les cosses du module. C\u0026rsquo;est fastidieux et ça a tendance à déconner. Le meilleur aurait de faire un PCB, mais quand on a pas le matériel, on se débrouille quand même !\nJe n\u0026rsquo;ai pas utilisé toutes les pins mais seulement les suivantes : 1, 2, 4, 5, 6, 7, 12, 16, 17, 25, 26, 29, 32.\nJ\u0026rsquo;ai préféré relier toutes les masses (GND sur le schéma) à la masse pour éviter au maximum les interférences. Je ne sais pas si c\u0026rsquo;est utile, mais ça me rassure. De plus, je n\u0026rsquo;ai choisi que les pins qui m\u0026rsquo;intéressaient à savoir les boutons, le son et l\u0026rsquo;alimentation. On peut très bien utiliser les pins Rx/Tx pour renommer le module Bluetooth par exemple (et remplacer cet affreux nom \u0026ldquo;BK8000L\u0026rdquo;).\nPlace maintenant au montage sur la carte. On prend une petite carte qui acceptera tous les composants. On colle dans un premier temps la batterie sur le circuit. Ensuite, on soude un à un les composants comme le stipule le schéma suivant :\nAssurez vous que les soudures soient bien faites afin de ne pas avoir de mauvaises surprises. De plus, prenez garde au soudage du module Bluetooth qui est extrêmement fastidieux compte tenu des petits espaces disponibles, d\u0026rsquo;où l\u0026rsquo;utilité des fils à wrapper.\nCela donne le résultat suivant. Vous avez théoriquement 4 fils non-reliés qui sont dédiés aux speakers. J\u0026rsquo;ai mis un fil supplémentaire qui est un câble USB directement soudé aux bornes du circuit de charge. J\u0026rsquo;ai donc un port femelle micro-USB ou un câble USB mâle sortant pour recharger facilement.\nPour les enceintes, il a fallu faire 2 caisses de résonnance adaptée aux haut-parleurs et aux dimensions de mon ourson. J\u0026rsquo;ai pris des tubes en carton trouvés par-ci par-là. A vous d\u0026rsquo;adapter comme vous le voulez ou pouvez afin d\u0026rsquo;avoir une bonne caisse de résonnance. Il n\u0026rsquo;y a pas de règle particulière si ce n\u0026rsquo;est que de bien fixer les HP pour éviter toute fuite d\u0026rsquo;air ou vibration.\nPour une prochaine version Douglas v1 souffrait de quelques petits problèmes ergonomiques.\nQuand quelqu\u0026rsquo;un le serrait dans ses bras (ce qui arrivait souvent), cela pouvait appuyer sur le bouton situé au niveau du ventre. Un appui long redémarre le module ce qui est frustrant lorsque de la musique est en route. Les boutons pour changer de chanson n\u0026rsquo;étaient quasiment jamais utilisés. Les boutons volumes seraient souhaitables mais pourraient ne pas être utilisés. Changer le volume sur le module s\u0026rsquo;effectue localement. Hors on pourrait souhaiter qu\u0026rsquo;un changement de volume sur Douglas se transmette au Smartphone afin que le volume s\u0026rsquo;actualise sur ce dernier. Le circuit de charge n\u0026rsquo;est pas facile d\u0026rsquo;accès. La carte en elle même n\u0026rsquo;est pas prévue pour une longue durée de vie, vu les soudures. Ce sont des petits problèmes qui n\u0026rsquo;en sont pas. Je pinaille, mais c\u0026rsquo;est suffisant pour se lancer dans une version 2 qui pourrait résoudre certains de ces problèmes !\nDe plus, j\u0026rsquo;aimerai bien passer pour la version 2 sur du 5W afin d\u0026rsquo;avoir plus de puissance.\nAutre chose qui m\u0026rsquo;embête, c\u0026rsquo;est le nom du module Bluetooth. En effet, il diffuse le nom \u0026ldquo;BK8000L\u0026rdquo;. Ce serait super chouette de pouvoir le modifier en Douglas par exemple.\nUn petit plus serait aussi de pouvoir rediriger le son vers une sortie jack. J\u0026rsquo;ai pensé à ça quand il y a une petite sono sans bluetooth, et qu\u0026rsquo;on souhaite quand même profiter du sans fil sans installation bancale.\nDe la même manière, pouvoir brancher un câble Jack dans Douglas pour bénificier de ses haut-parleurs pourrait être sympathique. Dans le module ci-dessus du moins, les ports Aux_L et Aux_R (20 et 19) ne sont malheureusement pas déportés. Si nous voulons les utiliser, il faudra souder deux fils sur la carte ce qui peut s\u0026rsquo;avérer laborieux et dangereux pour la carte.\nEnfin, je souhaiterai oublier les petites batteries Li-Ion si possible. En effet, dans une des enceintes que j\u0026rsquo;avais conçu, l\u0026rsquo;une d\u0026rsquo;elle avait gonflé et comme elles ne sont pas protégées, je ne suis pas rassurer.\nJe préfère utiliser des batteries externes car elles sont généralement protégées par un boitier, et ont une bien plus grande capacité.\n","date":"2014-01-01T00:00:00Z","image":"https://nicolasguilloux.eu/articles/douglas/cover_hu516228d592db0b9421f864dbb4b1650d_1516861_120x120_fill_box_smart1_3.png","permalink":"https://nicolasguilloux.eu/articles/douglas/","title":"Douglas"},{"content":"YANA est une interface domotique développée par Idleman. L\u0026rsquo;application Android permettait de dicter des ordres afin de déclencher les actions côté serveur. Elle servait donc d\u0026rsquo;interface portable pour controller l\u0026rsquo;installation.\nA cause de mes études, j\u0026rsquo;ai dû mettre de côté le développement de l\u0026rsquo;application pour au final l\u0026rsquo;abandonner. En effet, le serveur a beaucoup évolué sans que je puisse poursuivre les mises à jour. Une autre personne a continué le développement et est donc en charge par la suite de maintenir.\nJe remercie :\nValentin Carruesco pour le développement de YANA serveur. Alexandre Roland pour la reprise du développement de YANA Android. ","date":"2013-10-24T00:00:00Z","image":"https://raw.github.com/Etsuni/YANA/master/presentation.png","permalink":"https://nicolasguilloux.eu/articles/yana/","title":"Yana"}]